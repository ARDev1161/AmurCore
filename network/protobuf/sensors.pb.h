// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensors.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sensors_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sensors_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sensors_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sensors_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sensors_2eproto;
class AmurSensors;
class AmurSensorsDefaultTypeInternal;
extern AmurSensorsDefaultTypeInternal _AmurSensors_default_instance_;
class AmurSensors_Accelerometer;
class AmurSensors_AccelerometerDefaultTypeInternal;
extern AmurSensors_AccelerometerDefaultTypeInternal _AmurSensors_Accelerometer_default_instance_;
class AmurSensors_Gyroscope;
class AmurSensors_GyroscopeDefaultTypeInternal;
extern AmurSensors_GyroscopeDefaultTypeInternal _AmurSensors_Gyroscope_default_instance_;
class AmurSensors_HandCurrent;
class AmurSensors_HandCurrentDefaultTypeInternal;
extern AmurSensors_HandCurrentDefaultTypeInternal _AmurSensors_HandCurrent_default_instance_;
class AmurSensors_HandEncoders;
class AmurSensors_HandEncodersDefaultTypeInternal;
extern AmurSensors_HandEncodersDefaultTypeInternal _AmurSensors_HandEncoders_default_instance_;
class AmurSensors_Magnitometer;
class AmurSensors_MagnitometerDefaultTypeInternal;
extern AmurSensors_MagnitometerDefaultTypeInternal _AmurSensors_Magnitometer_default_instance_;
class AmurSensors_Misc;
class AmurSensors_MiscDefaultTypeInternal;
extern AmurSensors_MiscDefaultTypeInternal _AmurSensors_Misc_default_instance_;
class AmurSensors_Temperature;
class AmurSensors_TemperatureDefaultTypeInternal;
extern AmurSensors_TemperatureDefaultTypeInternal _AmurSensors_Temperature_default_instance_;
class AmurSensors_WheelCurrent;
class AmurSensors_WheelCurrentDefaultTypeInternal;
extern AmurSensors_WheelCurrentDefaultTypeInternal _AmurSensors_WheelCurrent_default_instance_;
class AmurSensors_WheelEncoders;
class AmurSensors_WheelEncodersDefaultTypeInternal;
extern AmurSensors_WheelEncodersDefaultTypeInternal _AmurSensors_WheelEncoders_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::AmurSensors* Arena::CreateMaybeMessage<::AmurSensors>(Arena*);
template<> ::AmurSensors_Accelerometer* Arena::CreateMaybeMessage<::AmurSensors_Accelerometer>(Arena*);
template<> ::AmurSensors_Gyroscope* Arena::CreateMaybeMessage<::AmurSensors_Gyroscope>(Arena*);
template<> ::AmurSensors_HandCurrent* Arena::CreateMaybeMessage<::AmurSensors_HandCurrent>(Arena*);
template<> ::AmurSensors_HandEncoders* Arena::CreateMaybeMessage<::AmurSensors_HandEncoders>(Arena*);
template<> ::AmurSensors_Magnitometer* Arena::CreateMaybeMessage<::AmurSensors_Magnitometer>(Arena*);
template<> ::AmurSensors_Misc* Arena::CreateMaybeMessage<::AmurSensors_Misc>(Arena*);
template<> ::AmurSensors_Temperature* Arena::CreateMaybeMessage<::AmurSensors_Temperature>(Arena*);
template<> ::AmurSensors_WheelCurrent* Arena::CreateMaybeMessage<::AmurSensors_WheelCurrent>(Arena*);
template<> ::AmurSensors_WheelEncoders* Arena::CreateMaybeMessage<::AmurSensors_WheelEncoders>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class AmurSensors_Accelerometer :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AmurSensors.Accelerometer) */ {
 public:
  AmurSensors_Accelerometer();
  virtual ~AmurSensors_Accelerometer();

  AmurSensors_Accelerometer(const AmurSensors_Accelerometer& from);
  AmurSensors_Accelerometer(AmurSensors_Accelerometer&& from) noexcept
    : AmurSensors_Accelerometer() {
    *this = ::std::move(from);
  }

  inline AmurSensors_Accelerometer& operator=(const AmurSensors_Accelerometer& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurSensors_Accelerometer& operator=(AmurSensors_Accelerometer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurSensors_Accelerometer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurSensors_Accelerometer* internal_default_instance() {
    return reinterpret_cast<const AmurSensors_Accelerometer*>(
               &_AmurSensors_Accelerometer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AmurSensors_Accelerometer& a, AmurSensors_Accelerometer& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurSensors_Accelerometer* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurSensors_Accelerometer* New() const final {
    return CreateMaybeMessage<AmurSensors_Accelerometer>(nullptr);
  }

  AmurSensors_Accelerometer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurSensors_Accelerometer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurSensors_Accelerometer& from);
  void MergeFrom(const AmurSensors_Accelerometer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurSensors_Accelerometer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AmurSensors.Accelerometer";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sensors_2eproto);
    return ::descriptor_table_sensors_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:AmurSensors.Accelerometer)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class AmurSensors_Gyroscope :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AmurSensors.Gyroscope) */ {
 public:
  AmurSensors_Gyroscope();
  virtual ~AmurSensors_Gyroscope();

  AmurSensors_Gyroscope(const AmurSensors_Gyroscope& from);
  AmurSensors_Gyroscope(AmurSensors_Gyroscope&& from) noexcept
    : AmurSensors_Gyroscope() {
    *this = ::std::move(from);
  }

  inline AmurSensors_Gyroscope& operator=(const AmurSensors_Gyroscope& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurSensors_Gyroscope& operator=(AmurSensors_Gyroscope&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurSensors_Gyroscope& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurSensors_Gyroscope* internal_default_instance() {
    return reinterpret_cast<const AmurSensors_Gyroscope*>(
               &_AmurSensors_Gyroscope_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AmurSensors_Gyroscope& a, AmurSensors_Gyroscope& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurSensors_Gyroscope* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurSensors_Gyroscope* New() const final {
    return CreateMaybeMessage<AmurSensors_Gyroscope>(nullptr);
  }

  AmurSensors_Gyroscope* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurSensors_Gyroscope>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurSensors_Gyroscope& from);
  void MergeFrom(const AmurSensors_Gyroscope& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurSensors_Gyroscope* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AmurSensors.Gyroscope";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sensors_2eproto);
    return ::descriptor_table_sensors_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:AmurSensors.Gyroscope)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class AmurSensors_Magnitometer :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AmurSensors.Magnitometer) */ {
 public:
  AmurSensors_Magnitometer();
  virtual ~AmurSensors_Magnitometer();

  AmurSensors_Magnitometer(const AmurSensors_Magnitometer& from);
  AmurSensors_Magnitometer(AmurSensors_Magnitometer&& from) noexcept
    : AmurSensors_Magnitometer() {
    *this = ::std::move(from);
  }

  inline AmurSensors_Magnitometer& operator=(const AmurSensors_Magnitometer& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurSensors_Magnitometer& operator=(AmurSensors_Magnitometer&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurSensors_Magnitometer& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurSensors_Magnitometer* internal_default_instance() {
    return reinterpret_cast<const AmurSensors_Magnitometer*>(
               &_AmurSensors_Magnitometer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AmurSensors_Magnitometer& a, AmurSensors_Magnitometer& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurSensors_Magnitometer* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurSensors_Magnitometer* New() const final {
    return CreateMaybeMessage<AmurSensors_Magnitometer>(nullptr);
  }

  AmurSensors_Magnitometer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurSensors_Magnitometer>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurSensors_Magnitometer& from);
  void MergeFrom(const AmurSensors_Magnitometer& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurSensors_Magnitometer* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AmurSensors.Magnitometer";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sensors_2eproto);
    return ::descriptor_table_sensors_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXFieldNumber = 1,
    kYFieldNumber = 2,
    kZFieldNumber = 3,
  };
  // float x = 1;
  void clear_x();
  float x() const;
  void set_x(float value);
  private:
  float _internal_x() const;
  void _internal_set_x(float value);
  public:

  // float y = 2;
  void clear_y();
  float y() const;
  void set_y(float value);
  private:
  float _internal_y() const;
  void _internal_set_y(float value);
  public:

  // float z = 3;
  void clear_z();
  float z() const;
  void set_z(float value);
  private:
  float _internal_z() const;
  void _internal_set_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:AmurSensors.Magnitometer)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  float x_;
  float y_;
  float z_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class AmurSensors_WheelEncoders :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AmurSensors.WheelEncoders) */ {
 public:
  AmurSensors_WheelEncoders();
  virtual ~AmurSensors_WheelEncoders();

  AmurSensors_WheelEncoders(const AmurSensors_WheelEncoders& from);
  AmurSensors_WheelEncoders(AmurSensors_WheelEncoders&& from) noexcept
    : AmurSensors_WheelEncoders() {
    *this = ::std::move(from);
  }

  inline AmurSensors_WheelEncoders& operator=(const AmurSensors_WheelEncoders& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurSensors_WheelEncoders& operator=(AmurSensors_WheelEncoders&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurSensors_WheelEncoders& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurSensors_WheelEncoders* internal_default_instance() {
    return reinterpret_cast<const AmurSensors_WheelEncoders*>(
               &_AmurSensors_WheelEncoders_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AmurSensors_WheelEncoders& a, AmurSensors_WheelEncoders& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurSensors_WheelEncoders* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurSensors_WheelEncoders* New() const final {
    return CreateMaybeMessage<AmurSensors_WheelEncoders>(nullptr);
  }

  AmurSensors_WheelEncoders* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurSensors_WheelEncoders>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurSensors_WheelEncoders& from);
  void MergeFrom(const AmurSensors_WheelEncoders& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurSensors_WheelEncoders* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AmurSensors.WheelEncoders";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sensors_2eproto);
    return ::descriptor_table_sensors_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftAngleFieldNumber = 1,
    kRightAngleFieldNumber = 2,
  };
  // int32 leftAngle = 1;
  void clear_leftangle();
  ::PROTOBUF_NAMESPACE_ID::int32 leftangle() const;
  void set_leftangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_leftangle() const;
  void _internal_set_leftangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 rightAngle = 2;
  void clear_rightangle();
  ::PROTOBUF_NAMESPACE_ID::int32 rightangle() const;
  void set_rightangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rightangle() const;
  void _internal_set_rightangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:AmurSensors.WheelEncoders)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 leftangle_;
  ::PROTOBUF_NAMESPACE_ID::int32 rightangle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class AmurSensors_HandEncoders :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AmurSensors.HandEncoders) */ {
 public:
  AmurSensors_HandEncoders();
  virtual ~AmurSensors_HandEncoders();

  AmurSensors_HandEncoders(const AmurSensors_HandEncoders& from);
  AmurSensors_HandEncoders(AmurSensors_HandEncoders&& from) noexcept
    : AmurSensors_HandEncoders() {
    *this = ::std::move(from);
  }

  inline AmurSensors_HandEncoders& operator=(const AmurSensors_HandEncoders& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurSensors_HandEncoders& operator=(AmurSensors_HandEncoders&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurSensors_HandEncoders& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurSensors_HandEncoders* internal_default_instance() {
    return reinterpret_cast<const AmurSensors_HandEncoders*>(
               &_AmurSensors_HandEncoders_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AmurSensors_HandEncoders& a, AmurSensors_HandEncoders& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurSensors_HandEncoders* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurSensors_HandEncoders* New() const final {
    return CreateMaybeMessage<AmurSensors_HandEncoders>(nullptr);
  }

  AmurSensors_HandEncoders* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurSensors_HandEncoders>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurSensors_HandEncoders& from);
  void MergeFrom(const AmurSensors_HandEncoders& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurSensors_HandEncoders* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AmurSensors.HandEncoders";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sensors_2eproto);
    return ::descriptor_table_sensors_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftInternalAngleFieldNumber = 1,
    kRightInternalAngleFieldNumber = 2,
    kLeftOuterAngleFieldNumber = 3,
    kRightOuterAngleFieldNumber = 4,
  };
  // int32 leftInternalAngle = 1;
  void clear_leftinternalangle();
  ::PROTOBUF_NAMESPACE_ID::int32 leftinternalangle() const;
  void set_leftinternalangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_leftinternalangle() const;
  void _internal_set_leftinternalangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 rightInternalAngle = 2;
  void clear_rightinternalangle();
  ::PROTOBUF_NAMESPACE_ID::int32 rightinternalangle() const;
  void set_rightinternalangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rightinternalangle() const;
  void _internal_set_rightinternalangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 leftOuterAngle = 3;
  void clear_leftouterangle();
  ::PROTOBUF_NAMESPACE_ID::int32 leftouterangle() const;
  void set_leftouterangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_leftouterangle() const;
  void _internal_set_leftouterangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 rightOuterAngle = 4;
  void clear_rightouterangle();
  ::PROTOBUF_NAMESPACE_ID::int32 rightouterangle() const;
  void set_rightouterangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rightouterangle() const;
  void _internal_set_rightouterangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:AmurSensors.HandEncoders)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 leftinternalangle_;
  ::PROTOBUF_NAMESPACE_ID::int32 rightinternalangle_;
  ::PROTOBUF_NAMESPACE_ID::int32 leftouterangle_;
  ::PROTOBUF_NAMESPACE_ID::int32 rightouterangle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class AmurSensors_Temperature :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AmurSensors.Temperature) */ {
 public:
  AmurSensors_Temperature();
  virtual ~AmurSensors_Temperature();

  AmurSensors_Temperature(const AmurSensors_Temperature& from);
  AmurSensors_Temperature(AmurSensors_Temperature&& from) noexcept
    : AmurSensors_Temperature() {
    *this = ::std::move(from);
  }

  inline AmurSensors_Temperature& operator=(const AmurSensors_Temperature& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurSensors_Temperature& operator=(AmurSensors_Temperature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurSensors_Temperature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurSensors_Temperature* internal_default_instance() {
    return reinterpret_cast<const AmurSensors_Temperature*>(
               &_AmurSensors_Temperature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AmurSensors_Temperature& a, AmurSensors_Temperature& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurSensors_Temperature* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurSensors_Temperature* New() const final {
    return CreateMaybeMessage<AmurSensors_Temperature>(nullptr);
  }

  AmurSensors_Temperature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurSensors_Temperature>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurSensors_Temperature& from);
  void MergeFrom(const AmurSensors_Temperature& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurSensors_Temperature* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AmurSensors.Temperature";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sensors_2eproto);
    return ::descriptor_table_sensors_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTempAccelerometerFieldNumber = 1,
    kTempCPUFieldNumber = 2,
    kTempPressureFieldNumber = 3,
  };
  // int32 tempAccelerometer = 1;
  void clear_tempaccelerometer();
  ::PROTOBUF_NAMESPACE_ID::int32 tempaccelerometer() const;
  void set_tempaccelerometer(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_tempaccelerometer() const;
  void _internal_set_tempaccelerometer(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 tempCPU = 2;
  void clear_tempcpu();
  ::PROTOBUF_NAMESPACE_ID::int32 tempcpu() const;
  void set_tempcpu(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_tempcpu() const;
  void _internal_set_tempcpu(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 tempPressure = 3;
  void clear_temppressure();
  ::PROTOBUF_NAMESPACE_ID::int32 temppressure() const;
  void set_temppressure(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_temppressure() const;
  void _internal_set_temppressure(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:AmurSensors.Temperature)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 tempaccelerometer_;
  ::PROTOBUF_NAMESPACE_ID::int32 tempcpu_;
  ::PROTOBUF_NAMESPACE_ID::int32 temppressure_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class AmurSensors_WheelCurrent :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AmurSensors.WheelCurrent) */ {
 public:
  AmurSensors_WheelCurrent();
  virtual ~AmurSensors_WheelCurrent();

  AmurSensors_WheelCurrent(const AmurSensors_WheelCurrent& from);
  AmurSensors_WheelCurrent(AmurSensors_WheelCurrent&& from) noexcept
    : AmurSensors_WheelCurrent() {
    *this = ::std::move(from);
  }

  inline AmurSensors_WheelCurrent& operator=(const AmurSensors_WheelCurrent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurSensors_WheelCurrent& operator=(AmurSensors_WheelCurrent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurSensors_WheelCurrent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurSensors_WheelCurrent* internal_default_instance() {
    return reinterpret_cast<const AmurSensors_WheelCurrent*>(
               &_AmurSensors_WheelCurrent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(AmurSensors_WheelCurrent& a, AmurSensors_WheelCurrent& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurSensors_WheelCurrent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurSensors_WheelCurrent* New() const final {
    return CreateMaybeMessage<AmurSensors_WheelCurrent>(nullptr);
  }

  AmurSensors_WheelCurrent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurSensors_WheelCurrent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurSensors_WheelCurrent& from);
  void MergeFrom(const AmurSensors_WheelCurrent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurSensors_WheelCurrent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AmurSensors.WheelCurrent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sensors_2eproto);
    return ::descriptor_table_sensors_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftCurrentFieldNumber = 1,
    kRightCurrentFieldNumber = 2,
  };
  // int32 leftCurrent = 1;
  void clear_leftcurrent();
  ::PROTOBUF_NAMESPACE_ID::int32 leftcurrent() const;
  void set_leftcurrent(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_leftcurrent() const;
  void _internal_set_leftcurrent(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 rightCurrent = 2;
  void clear_rightcurrent();
  ::PROTOBUF_NAMESPACE_ID::int32 rightcurrent() const;
  void set_rightcurrent(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rightcurrent() const;
  void _internal_set_rightcurrent(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:AmurSensors.WheelCurrent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 leftcurrent_;
  ::PROTOBUF_NAMESPACE_ID::int32 rightcurrent_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class AmurSensors_HandCurrent :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AmurSensors.HandCurrent) */ {
 public:
  AmurSensors_HandCurrent();
  virtual ~AmurSensors_HandCurrent();

  AmurSensors_HandCurrent(const AmurSensors_HandCurrent& from);
  AmurSensors_HandCurrent(AmurSensors_HandCurrent&& from) noexcept
    : AmurSensors_HandCurrent() {
    *this = ::std::move(from);
  }

  inline AmurSensors_HandCurrent& operator=(const AmurSensors_HandCurrent& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurSensors_HandCurrent& operator=(AmurSensors_HandCurrent&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurSensors_HandCurrent& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurSensors_HandCurrent* internal_default_instance() {
    return reinterpret_cast<const AmurSensors_HandCurrent*>(
               &_AmurSensors_HandCurrent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(AmurSensors_HandCurrent& a, AmurSensors_HandCurrent& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurSensors_HandCurrent* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurSensors_HandCurrent* New() const final {
    return CreateMaybeMessage<AmurSensors_HandCurrent>(nullptr);
  }

  AmurSensors_HandCurrent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurSensors_HandCurrent>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurSensors_HandCurrent& from);
  void MergeFrom(const AmurSensors_HandCurrent& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurSensors_HandCurrent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AmurSensors.HandCurrent";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sensors_2eproto);
    return ::descriptor_table_sensors_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftCurrentFieldNumber = 1,
    kRightCurrentFieldNumber = 2,
  };
  // int32 leftCurrent = 1;
  void clear_leftcurrent();
  ::PROTOBUF_NAMESPACE_ID::int32 leftcurrent() const;
  void set_leftcurrent(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_leftcurrent() const;
  void _internal_set_leftcurrent(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 rightCurrent = 2;
  void clear_rightcurrent();
  ::PROTOBUF_NAMESPACE_ID::int32 rightcurrent() const;
  void set_rightcurrent(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rightcurrent() const;
  void _internal_set_rightcurrent(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:AmurSensors.HandCurrent)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 leftcurrent_;
  ::PROTOBUF_NAMESPACE_ID::int32 rightcurrent_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class AmurSensors_Misc :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AmurSensors.Misc) */ {
 public:
  AmurSensors_Misc();
  virtual ~AmurSensors_Misc();

  AmurSensors_Misc(const AmurSensors_Misc& from);
  AmurSensors_Misc(AmurSensors_Misc&& from) noexcept
    : AmurSensors_Misc() {
    *this = ::std::move(from);
  }

  inline AmurSensors_Misc& operator=(const AmurSensors_Misc& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurSensors_Misc& operator=(AmurSensors_Misc&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurSensors_Misc& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurSensors_Misc* internal_default_instance() {
    return reinterpret_cast<const AmurSensors_Misc*>(
               &_AmurSensors_Misc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(AmurSensors_Misc& a, AmurSensors_Misc& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurSensors_Misc* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurSensors_Misc* New() const final {
    return CreateMaybeMessage<AmurSensors_Misc>(nullptr);
  }

  AmurSensors_Misc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurSensors_Misc>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurSensors_Misc& from);
  void MergeFrom(const AmurSensors_Misc& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurSensors_Misc* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AmurSensors.Misc";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sensors_2eproto);
    return ::descriptor_table_sensors_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGasFieldNumber = 1,
    kBatteryVoltageFieldNumber = 2,
    kRaspberryVoltageFieldNumber = 3,
    kPressureFieldNumber = 4,
  };
  // int32 gas = 1;
  void clear_gas();
  ::PROTOBUF_NAMESPACE_ID::int32 gas() const;
  void set_gas(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_gas() const;
  void _internal_set_gas(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 batteryVoltage = 2;
  void clear_batteryvoltage();
  ::PROTOBUF_NAMESPACE_ID::int32 batteryvoltage() const;
  void set_batteryvoltage(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_batteryvoltage() const;
  void _internal_set_batteryvoltage(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 raspberryVoltage = 3;
  void clear_raspberryvoltage();
  ::PROTOBUF_NAMESPACE_ID::int32 raspberryvoltage() const;
  void set_raspberryvoltage(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_raspberryvoltage() const;
  void _internal_set_raspberryvoltage(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // float pressure = 4;
  void clear_pressure();
  float pressure() const;
  void set_pressure(float value);
  private:
  float _internal_pressure() const;
  void _internal_set_pressure(float value);
  public:

  // @@protoc_insertion_point(class_scope:AmurSensors.Misc)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 gas_;
  ::PROTOBUF_NAMESPACE_ID::int32 batteryvoltage_;
  ::PROTOBUF_NAMESPACE_ID::int32 raspberryvoltage_;
  float pressure_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// -------------------------------------------------------------------

class AmurSensors :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AmurSensors) */ {
 public:
  AmurSensors();
  virtual ~AmurSensors();

  AmurSensors(const AmurSensors& from);
  AmurSensors(AmurSensors&& from) noexcept
    : AmurSensors() {
    *this = ::std::move(from);
  }

  inline AmurSensors& operator=(const AmurSensors& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurSensors& operator=(AmurSensors&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurSensors& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurSensors* internal_default_instance() {
    return reinterpret_cast<const AmurSensors*>(
               &_AmurSensors_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(AmurSensors& a, AmurSensors& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurSensors* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurSensors* New() const final {
    return CreateMaybeMessage<AmurSensors>(nullptr);
  }

  AmurSensors* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurSensors>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurSensors& from);
  void MergeFrom(const AmurSensors& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurSensors* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AmurSensors";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_sensors_2eproto);
    return ::descriptor_table_sensors_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef AmurSensors_Accelerometer Accelerometer;
  typedef AmurSensors_Gyroscope Gyroscope;
  typedef AmurSensors_Magnitometer Magnitometer;
  typedef AmurSensors_WheelEncoders WheelEncoders;
  typedef AmurSensors_HandEncoders HandEncoders;
  typedef AmurSensors_Temperature Temperature;
  typedef AmurSensors_WheelCurrent WheelCurrent;
  typedef AmurSensors_HandCurrent HandCurrent;
  typedef AmurSensors_Misc Misc;

  // accessors -------------------------------------------------------

  enum : int {
    kAccelerometerFieldNumber = 1,
    kGyroscopeFieldNumber = 2,
    kMagnitometerFieldNumber = 3,
    kWheelEncodersFieldNumber = 4,
    kHandEncodersFieldNumber = 5,
    kTemperatureFieldNumber = 6,
    kMiscFieldNumber = 7,
  };
  // .AmurSensors.Accelerometer accelerometer = 1;
  bool has_accelerometer() const;
  private:
  bool _internal_has_accelerometer() const;
  public:
  void clear_accelerometer();
  const ::AmurSensors_Accelerometer& accelerometer() const;
  ::AmurSensors_Accelerometer* release_accelerometer();
  ::AmurSensors_Accelerometer* mutable_accelerometer();
  void set_allocated_accelerometer(::AmurSensors_Accelerometer* accelerometer);
  private:
  const ::AmurSensors_Accelerometer& _internal_accelerometer() const;
  ::AmurSensors_Accelerometer* _internal_mutable_accelerometer();
  public:

  // .AmurSensors.Gyroscope gyroscope = 2;
  bool has_gyroscope() const;
  private:
  bool _internal_has_gyroscope() const;
  public:
  void clear_gyroscope();
  const ::AmurSensors_Gyroscope& gyroscope() const;
  ::AmurSensors_Gyroscope* release_gyroscope();
  ::AmurSensors_Gyroscope* mutable_gyroscope();
  void set_allocated_gyroscope(::AmurSensors_Gyroscope* gyroscope);
  private:
  const ::AmurSensors_Gyroscope& _internal_gyroscope() const;
  ::AmurSensors_Gyroscope* _internal_mutable_gyroscope();
  public:

  // .AmurSensors.Magnitometer magnitometer = 3;
  bool has_magnitometer() const;
  private:
  bool _internal_has_magnitometer() const;
  public:
  void clear_magnitometer();
  const ::AmurSensors_Magnitometer& magnitometer() const;
  ::AmurSensors_Magnitometer* release_magnitometer();
  ::AmurSensors_Magnitometer* mutable_magnitometer();
  void set_allocated_magnitometer(::AmurSensors_Magnitometer* magnitometer);
  private:
  const ::AmurSensors_Magnitometer& _internal_magnitometer() const;
  ::AmurSensors_Magnitometer* _internal_mutable_magnitometer();
  public:

  // .AmurSensors.WheelEncoders wheelEncoders = 4;
  bool has_wheelencoders() const;
  private:
  bool _internal_has_wheelencoders() const;
  public:
  void clear_wheelencoders();
  const ::AmurSensors_WheelEncoders& wheelencoders() const;
  ::AmurSensors_WheelEncoders* release_wheelencoders();
  ::AmurSensors_WheelEncoders* mutable_wheelencoders();
  void set_allocated_wheelencoders(::AmurSensors_WheelEncoders* wheelencoders);
  private:
  const ::AmurSensors_WheelEncoders& _internal_wheelencoders() const;
  ::AmurSensors_WheelEncoders* _internal_mutable_wheelencoders();
  public:

  // .AmurSensors.HandEncoders handEncoders = 5;
  bool has_handencoders() const;
  private:
  bool _internal_has_handencoders() const;
  public:
  void clear_handencoders();
  const ::AmurSensors_HandEncoders& handencoders() const;
  ::AmurSensors_HandEncoders* release_handencoders();
  ::AmurSensors_HandEncoders* mutable_handencoders();
  void set_allocated_handencoders(::AmurSensors_HandEncoders* handencoders);
  private:
  const ::AmurSensors_HandEncoders& _internal_handencoders() const;
  ::AmurSensors_HandEncoders* _internal_mutable_handencoders();
  public:

  // .AmurSensors.Temperature temperature = 6;
  bool has_temperature() const;
  private:
  bool _internal_has_temperature() const;
  public:
  void clear_temperature();
  const ::AmurSensors_Temperature& temperature() const;
  ::AmurSensors_Temperature* release_temperature();
  ::AmurSensors_Temperature* mutable_temperature();
  void set_allocated_temperature(::AmurSensors_Temperature* temperature);
  private:
  const ::AmurSensors_Temperature& _internal_temperature() const;
  ::AmurSensors_Temperature* _internal_mutable_temperature();
  public:

  // .AmurSensors.Misc misc = 7;
  bool has_misc() const;
  private:
  bool _internal_has_misc() const;
  public:
  void clear_misc();
  const ::AmurSensors_Misc& misc() const;
  ::AmurSensors_Misc* release_misc();
  ::AmurSensors_Misc* mutable_misc();
  void set_allocated_misc(::AmurSensors_Misc* misc);
  private:
  const ::AmurSensors_Misc& _internal_misc() const;
  ::AmurSensors_Misc* _internal_mutable_misc();
  public:

  // @@protoc_insertion_point(class_scope:AmurSensors)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::AmurSensors_Accelerometer* accelerometer_;
  ::AmurSensors_Gyroscope* gyroscope_;
  ::AmurSensors_Magnitometer* magnitometer_;
  ::AmurSensors_WheelEncoders* wheelencoders_;
  ::AmurSensors_HandEncoders* handencoders_;
  ::AmurSensors_Temperature* temperature_;
  ::AmurSensors_Misc* misc_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_sensors_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AmurSensors_Accelerometer

// float x = 1;
inline void AmurSensors_Accelerometer::clear_x() {
  x_ = 0;
}
inline float AmurSensors_Accelerometer::_internal_x() const {
  return x_;
}
inline float AmurSensors_Accelerometer::x() const {
  // @@protoc_insertion_point(field_get:AmurSensors.Accelerometer.x)
  return _internal_x();
}
inline void AmurSensors_Accelerometer::_internal_set_x(float value) {
  
  x_ = value;
}
inline void AmurSensors_Accelerometer::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:AmurSensors.Accelerometer.x)
}

// float y = 2;
inline void AmurSensors_Accelerometer::clear_y() {
  y_ = 0;
}
inline float AmurSensors_Accelerometer::_internal_y() const {
  return y_;
}
inline float AmurSensors_Accelerometer::y() const {
  // @@protoc_insertion_point(field_get:AmurSensors.Accelerometer.y)
  return _internal_y();
}
inline void AmurSensors_Accelerometer::_internal_set_y(float value) {
  
  y_ = value;
}
inline void AmurSensors_Accelerometer::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:AmurSensors.Accelerometer.y)
}

// float z = 3;
inline void AmurSensors_Accelerometer::clear_z() {
  z_ = 0;
}
inline float AmurSensors_Accelerometer::_internal_z() const {
  return z_;
}
inline float AmurSensors_Accelerometer::z() const {
  // @@protoc_insertion_point(field_get:AmurSensors.Accelerometer.z)
  return _internal_z();
}
inline void AmurSensors_Accelerometer::_internal_set_z(float value) {
  
  z_ = value;
}
inline void AmurSensors_Accelerometer::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:AmurSensors.Accelerometer.z)
}

// -------------------------------------------------------------------

// AmurSensors_Gyroscope

// float x = 1;
inline void AmurSensors_Gyroscope::clear_x() {
  x_ = 0;
}
inline float AmurSensors_Gyroscope::_internal_x() const {
  return x_;
}
inline float AmurSensors_Gyroscope::x() const {
  // @@protoc_insertion_point(field_get:AmurSensors.Gyroscope.x)
  return _internal_x();
}
inline void AmurSensors_Gyroscope::_internal_set_x(float value) {
  
  x_ = value;
}
inline void AmurSensors_Gyroscope::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:AmurSensors.Gyroscope.x)
}

// float y = 2;
inline void AmurSensors_Gyroscope::clear_y() {
  y_ = 0;
}
inline float AmurSensors_Gyroscope::_internal_y() const {
  return y_;
}
inline float AmurSensors_Gyroscope::y() const {
  // @@protoc_insertion_point(field_get:AmurSensors.Gyroscope.y)
  return _internal_y();
}
inline void AmurSensors_Gyroscope::_internal_set_y(float value) {
  
  y_ = value;
}
inline void AmurSensors_Gyroscope::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:AmurSensors.Gyroscope.y)
}

// float z = 3;
inline void AmurSensors_Gyroscope::clear_z() {
  z_ = 0;
}
inline float AmurSensors_Gyroscope::_internal_z() const {
  return z_;
}
inline float AmurSensors_Gyroscope::z() const {
  // @@protoc_insertion_point(field_get:AmurSensors.Gyroscope.z)
  return _internal_z();
}
inline void AmurSensors_Gyroscope::_internal_set_z(float value) {
  
  z_ = value;
}
inline void AmurSensors_Gyroscope::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:AmurSensors.Gyroscope.z)
}

// -------------------------------------------------------------------

// AmurSensors_Magnitometer

// float x = 1;
inline void AmurSensors_Magnitometer::clear_x() {
  x_ = 0;
}
inline float AmurSensors_Magnitometer::_internal_x() const {
  return x_;
}
inline float AmurSensors_Magnitometer::x() const {
  // @@protoc_insertion_point(field_get:AmurSensors.Magnitometer.x)
  return _internal_x();
}
inline void AmurSensors_Magnitometer::_internal_set_x(float value) {
  
  x_ = value;
}
inline void AmurSensors_Magnitometer::set_x(float value) {
  _internal_set_x(value);
  // @@protoc_insertion_point(field_set:AmurSensors.Magnitometer.x)
}

// float y = 2;
inline void AmurSensors_Magnitometer::clear_y() {
  y_ = 0;
}
inline float AmurSensors_Magnitometer::_internal_y() const {
  return y_;
}
inline float AmurSensors_Magnitometer::y() const {
  // @@protoc_insertion_point(field_get:AmurSensors.Magnitometer.y)
  return _internal_y();
}
inline void AmurSensors_Magnitometer::_internal_set_y(float value) {
  
  y_ = value;
}
inline void AmurSensors_Magnitometer::set_y(float value) {
  _internal_set_y(value);
  // @@protoc_insertion_point(field_set:AmurSensors.Magnitometer.y)
}

// float z = 3;
inline void AmurSensors_Magnitometer::clear_z() {
  z_ = 0;
}
inline float AmurSensors_Magnitometer::_internal_z() const {
  return z_;
}
inline float AmurSensors_Magnitometer::z() const {
  // @@protoc_insertion_point(field_get:AmurSensors.Magnitometer.z)
  return _internal_z();
}
inline void AmurSensors_Magnitometer::_internal_set_z(float value) {
  
  z_ = value;
}
inline void AmurSensors_Magnitometer::set_z(float value) {
  _internal_set_z(value);
  // @@protoc_insertion_point(field_set:AmurSensors.Magnitometer.z)
}

// -------------------------------------------------------------------

// AmurSensors_WheelEncoders

// int32 leftAngle = 1;
inline void AmurSensors_WheelEncoders::clear_leftangle() {
  leftangle_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_WheelEncoders::_internal_leftangle() const {
  return leftangle_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_WheelEncoders::leftangle() const {
  // @@protoc_insertion_point(field_get:AmurSensors.WheelEncoders.leftAngle)
  return _internal_leftangle();
}
inline void AmurSensors_WheelEncoders::_internal_set_leftangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  leftangle_ = value;
}
inline void AmurSensors_WheelEncoders::set_leftangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_leftangle(value);
  // @@protoc_insertion_point(field_set:AmurSensors.WheelEncoders.leftAngle)
}

// int32 rightAngle = 2;
inline void AmurSensors_WheelEncoders::clear_rightangle() {
  rightangle_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_WheelEncoders::_internal_rightangle() const {
  return rightangle_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_WheelEncoders::rightangle() const {
  // @@protoc_insertion_point(field_get:AmurSensors.WheelEncoders.rightAngle)
  return _internal_rightangle();
}
inline void AmurSensors_WheelEncoders::_internal_set_rightangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  rightangle_ = value;
}
inline void AmurSensors_WheelEncoders::set_rightangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rightangle(value);
  // @@protoc_insertion_point(field_set:AmurSensors.WheelEncoders.rightAngle)
}

// -------------------------------------------------------------------

// AmurSensors_HandEncoders

// int32 leftInternalAngle = 1;
inline void AmurSensors_HandEncoders::clear_leftinternalangle() {
  leftinternalangle_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_HandEncoders::_internal_leftinternalangle() const {
  return leftinternalangle_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_HandEncoders::leftinternalangle() const {
  // @@protoc_insertion_point(field_get:AmurSensors.HandEncoders.leftInternalAngle)
  return _internal_leftinternalangle();
}
inline void AmurSensors_HandEncoders::_internal_set_leftinternalangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  leftinternalangle_ = value;
}
inline void AmurSensors_HandEncoders::set_leftinternalangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_leftinternalangle(value);
  // @@protoc_insertion_point(field_set:AmurSensors.HandEncoders.leftInternalAngle)
}

// int32 rightInternalAngle = 2;
inline void AmurSensors_HandEncoders::clear_rightinternalangle() {
  rightinternalangle_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_HandEncoders::_internal_rightinternalangle() const {
  return rightinternalangle_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_HandEncoders::rightinternalangle() const {
  // @@protoc_insertion_point(field_get:AmurSensors.HandEncoders.rightInternalAngle)
  return _internal_rightinternalangle();
}
inline void AmurSensors_HandEncoders::_internal_set_rightinternalangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  rightinternalangle_ = value;
}
inline void AmurSensors_HandEncoders::set_rightinternalangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rightinternalangle(value);
  // @@protoc_insertion_point(field_set:AmurSensors.HandEncoders.rightInternalAngle)
}

// int32 leftOuterAngle = 3;
inline void AmurSensors_HandEncoders::clear_leftouterangle() {
  leftouterangle_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_HandEncoders::_internal_leftouterangle() const {
  return leftouterangle_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_HandEncoders::leftouterangle() const {
  // @@protoc_insertion_point(field_get:AmurSensors.HandEncoders.leftOuterAngle)
  return _internal_leftouterangle();
}
inline void AmurSensors_HandEncoders::_internal_set_leftouterangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  leftouterangle_ = value;
}
inline void AmurSensors_HandEncoders::set_leftouterangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_leftouterangle(value);
  // @@protoc_insertion_point(field_set:AmurSensors.HandEncoders.leftOuterAngle)
}

// int32 rightOuterAngle = 4;
inline void AmurSensors_HandEncoders::clear_rightouterangle() {
  rightouterangle_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_HandEncoders::_internal_rightouterangle() const {
  return rightouterangle_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_HandEncoders::rightouterangle() const {
  // @@protoc_insertion_point(field_get:AmurSensors.HandEncoders.rightOuterAngle)
  return _internal_rightouterangle();
}
inline void AmurSensors_HandEncoders::_internal_set_rightouterangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  rightouterangle_ = value;
}
inline void AmurSensors_HandEncoders::set_rightouterangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rightouterangle(value);
  // @@protoc_insertion_point(field_set:AmurSensors.HandEncoders.rightOuterAngle)
}

// -------------------------------------------------------------------

// AmurSensors_Temperature

// int32 tempAccelerometer = 1;
inline void AmurSensors_Temperature::clear_tempaccelerometer() {
  tempaccelerometer_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_Temperature::_internal_tempaccelerometer() const {
  return tempaccelerometer_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_Temperature::tempaccelerometer() const {
  // @@protoc_insertion_point(field_get:AmurSensors.Temperature.tempAccelerometer)
  return _internal_tempaccelerometer();
}
inline void AmurSensors_Temperature::_internal_set_tempaccelerometer(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  tempaccelerometer_ = value;
}
inline void AmurSensors_Temperature::set_tempaccelerometer(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_tempaccelerometer(value);
  // @@protoc_insertion_point(field_set:AmurSensors.Temperature.tempAccelerometer)
}

// int32 tempCPU = 2;
inline void AmurSensors_Temperature::clear_tempcpu() {
  tempcpu_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_Temperature::_internal_tempcpu() const {
  return tempcpu_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_Temperature::tempcpu() const {
  // @@protoc_insertion_point(field_get:AmurSensors.Temperature.tempCPU)
  return _internal_tempcpu();
}
inline void AmurSensors_Temperature::_internal_set_tempcpu(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  tempcpu_ = value;
}
inline void AmurSensors_Temperature::set_tempcpu(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_tempcpu(value);
  // @@protoc_insertion_point(field_set:AmurSensors.Temperature.tempCPU)
}

// int32 tempPressure = 3;
inline void AmurSensors_Temperature::clear_temppressure() {
  temppressure_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_Temperature::_internal_temppressure() const {
  return temppressure_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_Temperature::temppressure() const {
  // @@protoc_insertion_point(field_get:AmurSensors.Temperature.tempPressure)
  return _internal_temppressure();
}
inline void AmurSensors_Temperature::_internal_set_temppressure(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  temppressure_ = value;
}
inline void AmurSensors_Temperature::set_temppressure(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_temppressure(value);
  // @@protoc_insertion_point(field_set:AmurSensors.Temperature.tempPressure)
}

// -------------------------------------------------------------------

// AmurSensors_WheelCurrent

// int32 leftCurrent = 1;
inline void AmurSensors_WheelCurrent::clear_leftcurrent() {
  leftcurrent_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_WheelCurrent::_internal_leftcurrent() const {
  return leftcurrent_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_WheelCurrent::leftcurrent() const {
  // @@protoc_insertion_point(field_get:AmurSensors.WheelCurrent.leftCurrent)
  return _internal_leftcurrent();
}
inline void AmurSensors_WheelCurrent::_internal_set_leftcurrent(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  leftcurrent_ = value;
}
inline void AmurSensors_WheelCurrent::set_leftcurrent(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_leftcurrent(value);
  // @@protoc_insertion_point(field_set:AmurSensors.WheelCurrent.leftCurrent)
}

// int32 rightCurrent = 2;
inline void AmurSensors_WheelCurrent::clear_rightcurrent() {
  rightcurrent_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_WheelCurrent::_internal_rightcurrent() const {
  return rightcurrent_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_WheelCurrent::rightcurrent() const {
  // @@protoc_insertion_point(field_get:AmurSensors.WheelCurrent.rightCurrent)
  return _internal_rightcurrent();
}
inline void AmurSensors_WheelCurrent::_internal_set_rightcurrent(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  rightcurrent_ = value;
}
inline void AmurSensors_WheelCurrent::set_rightcurrent(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rightcurrent(value);
  // @@protoc_insertion_point(field_set:AmurSensors.WheelCurrent.rightCurrent)
}

// -------------------------------------------------------------------

// AmurSensors_HandCurrent

// int32 leftCurrent = 1;
inline void AmurSensors_HandCurrent::clear_leftcurrent() {
  leftcurrent_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_HandCurrent::_internal_leftcurrent() const {
  return leftcurrent_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_HandCurrent::leftcurrent() const {
  // @@protoc_insertion_point(field_get:AmurSensors.HandCurrent.leftCurrent)
  return _internal_leftcurrent();
}
inline void AmurSensors_HandCurrent::_internal_set_leftcurrent(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  leftcurrent_ = value;
}
inline void AmurSensors_HandCurrent::set_leftcurrent(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_leftcurrent(value);
  // @@protoc_insertion_point(field_set:AmurSensors.HandCurrent.leftCurrent)
}

// int32 rightCurrent = 2;
inline void AmurSensors_HandCurrent::clear_rightcurrent() {
  rightcurrent_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_HandCurrent::_internal_rightcurrent() const {
  return rightcurrent_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_HandCurrent::rightcurrent() const {
  // @@protoc_insertion_point(field_get:AmurSensors.HandCurrent.rightCurrent)
  return _internal_rightcurrent();
}
inline void AmurSensors_HandCurrent::_internal_set_rightcurrent(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  rightcurrent_ = value;
}
inline void AmurSensors_HandCurrent::set_rightcurrent(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rightcurrent(value);
  // @@protoc_insertion_point(field_set:AmurSensors.HandCurrent.rightCurrent)
}

// -------------------------------------------------------------------

// AmurSensors_Misc

// int32 gas = 1;
inline void AmurSensors_Misc::clear_gas() {
  gas_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_Misc::_internal_gas() const {
  return gas_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_Misc::gas() const {
  // @@protoc_insertion_point(field_get:AmurSensors.Misc.gas)
  return _internal_gas();
}
inline void AmurSensors_Misc::_internal_set_gas(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  gas_ = value;
}
inline void AmurSensors_Misc::set_gas(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_gas(value);
  // @@protoc_insertion_point(field_set:AmurSensors.Misc.gas)
}

// int32 batteryVoltage = 2;
inline void AmurSensors_Misc::clear_batteryvoltage() {
  batteryvoltage_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_Misc::_internal_batteryvoltage() const {
  return batteryvoltage_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_Misc::batteryvoltage() const {
  // @@protoc_insertion_point(field_get:AmurSensors.Misc.batteryVoltage)
  return _internal_batteryvoltage();
}
inline void AmurSensors_Misc::_internal_set_batteryvoltage(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  batteryvoltage_ = value;
}
inline void AmurSensors_Misc::set_batteryvoltage(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_batteryvoltage(value);
  // @@protoc_insertion_point(field_set:AmurSensors.Misc.batteryVoltage)
}

// int32 raspberryVoltage = 3;
inline void AmurSensors_Misc::clear_raspberryvoltage() {
  raspberryvoltage_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_Misc::_internal_raspberryvoltage() const {
  return raspberryvoltage_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurSensors_Misc::raspberryvoltage() const {
  // @@protoc_insertion_point(field_get:AmurSensors.Misc.raspberryVoltage)
  return _internal_raspberryvoltage();
}
inline void AmurSensors_Misc::_internal_set_raspberryvoltage(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  raspberryvoltage_ = value;
}
inline void AmurSensors_Misc::set_raspberryvoltage(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_raspberryvoltage(value);
  // @@protoc_insertion_point(field_set:AmurSensors.Misc.raspberryVoltage)
}

// float pressure = 4;
inline void AmurSensors_Misc::clear_pressure() {
  pressure_ = 0;
}
inline float AmurSensors_Misc::_internal_pressure() const {
  return pressure_;
}
inline float AmurSensors_Misc::pressure() const {
  // @@protoc_insertion_point(field_get:AmurSensors.Misc.pressure)
  return _internal_pressure();
}
inline void AmurSensors_Misc::_internal_set_pressure(float value) {
  
  pressure_ = value;
}
inline void AmurSensors_Misc::set_pressure(float value) {
  _internal_set_pressure(value);
  // @@protoc_insertion_point(field_set:AmurSensors.Misc.pressure)
}

// -------------------------------------------------------------------

// AmurSensors

// .AmurSensors.Accelerometer accelerometer = 1;
inline bool AmurSensors::_internal_has_accelerometer() const {
  return this != internal_default_instance() && accelerometer_ != nullptr;
}
inline bool AmurSensors::has_accelerometer() const {
  return _internal_has_accelerometer();
}
inline void AmurSensors::clear_accelerometer() {
  if (GetArenaNoVirtual() == nullptr && accelerometer_ != nullptr) {
    delete accelerometer_;
  }
  accelerometer_ = nullptr;
}
inline const ::AmurSensors_Accelerometer& AmurSensors::_internal_accelerometer() const {
  const ::AmurSensors_Accelerometer* p = accelerometer_;
  return p != nullptr ? *p : *reinterpret_cast<const ::AmurSensors_Accelerometer*>(
      &::_AmurSensors_Accelerometer_default_instance_);
}
inline const ::AmurSensors_Accelerometer& AmurSensors::accelerometer() const {
  // @@protoc_insertion_point(field_get:AmurSensors.accelerometer)
  return _internal_accelerometer();
}
inline ::AmurSensors_Accelerometer* AmurSensors::release_accelerometer() {
  // @@protoc_insertion_point(field_release:AmurSensors.accelerometer)
  
  ::AmurSensors_Accelerometer* temp = accelerometer_;
  accelerometer_ = nullptr;
  return temp;
}
inline ::AmurSensors_Accelerometer* AmurSensors::_internal_mutable_accelerometer() {
  
  if (accelerometer_ == nullptr) {
    auto* p = CreateMaybeMessage<::AmurSensors_Accelerometer>(GetArenaNoVirtual());
    accelerometer_ = p;
  }
  return accelerometer_;
}
inline ::AmurSensors_Accelerometer* AmurSensors::mutable_accelerometer() {
  // @@protoc_insertion_point(field_mutable:AmurSensors.accelerometer)
  return _internal_mutable_accelerometer();
}
inline void AmurSensors::set_allocated_accelerometer(::AmurSensors_Accelerometer* accelerometer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete accelerometer_;
  }
  if (accelerometer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      accelerometer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, accelerometer, submessage_arena);
    }
    
  } else {
    
  }
  accelerometer_ = accelerometer;
  // @@protoc_insertion_point(field_set_allocated:AmurSensors.accelerometer)
}

// .AmurSensors.Gyroscope gyroscope = 2;
inline bool AmurSensors::_internal_has_gyroscope() const {
  return this != internal_default_instance() && gyroscope_ != nullptr;
}
inline bool AmurSensors::has_gyroscope() const {
  return _internal_has_gyroscope();
}
inline void AmurSensors::clear_gyroscope() {
  if (GetArenaNoVirtual() == nullptr && gyroscope_ != nullptr) {
    delete gyroscope_;
  }
  gyroscope_ = nullptr;
}
inline const ::AmurSensors_Gyroscope& AmurSensors::_internal_gyroscope() const {
  const ::AmurSensors_Gyroscope* p = gyroscope_;
  return p != nullptr ? *p : *reinterpret_cast<const ::AmurSensors_Gyroscope*>(
      &::_AmurSensors_Gyroscope_default_instance_);
}
inline const ::AmurSensors_Gyroscope& AmurSensors::gyroscope() const {
  // @@protoc_insertion_point(field_get:AmurSensors.gyroscope)
  return _internal_gyroscope();
}
inline ::AmurSensors_Gyroscope* AmurSensors::release_gyroscope() {
  // @@protoc_insertion_point(field_release:AmurSensors.gyroscope)
  
  ::AmurSensors_Gyroscope* temp = gyroscope_;
  gyroscope_ = nullptr;
  return temp;
}
inline ::AmurSensors_Gyroscope* AmurSensors::_internal_mutable_gyroscope() {
  
  if (gyroscope_ == nullptr) {
    auto* p = CreateMaybeMessage<::AmurSensors_Gyroscope>(GetArenaNoVirtual());
    gyroscope_ = p;
  }
  return gyroscope_;
}
inline ::AmurSensors_Gyroscope* AmurSensors::mutable_gyroscope() {
  // @@protoc_insertion_point(field_mutable:AmurSensors.gyroscope)
  return _internal_mutable_gyroscope();
}
inline void AmurSensors::set_allocated_gyroscope(::AmurSensors_Gyroscope* gyroscope) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete gyroscope_;
  }
  if (gyroscope) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      gyroscope = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, gyroscope, submessage_arena);
    }
    
  } else {
    
  }
  gyroscope_ = gyroscope;
  // @@protoc_insertion_point(field_set_allocated:AmurSensors.gyroscope)
}

// .AmurSensors.Magnitometer magnitometer = 3;
inline bool AmurSensors::_internal_has_magnitometer() const {
  return this != internal_default_instance() && magnitometer_ != nullptr;
}
inline bool AmurSensors::has_magnitometer() const {
  return _internal_has_magnitometer();
}
inline void AmurSensors::clear_magnitometer() {
  if (GetArenaNoVirtual() == nullptr && magnitometer_ != nullptr) {
    delete magnitometer_;
  }
  magnitometer_ = nullptr;
}
inline const ::AmurSensors_Magnitometer& AmurSensors::_internal_magnitometer() const {
  const ::AmurSensors_Magnitometer* p = magnitometer_;
  return p != nullptr ? *p : *reinterpret_cast<const ::AmurSensors_Magnitometer*>(
      &::_AmurSensors_Magnitometer_default_instance_);
}
inline const ::AmurSensors_Magnitometer& AmurSensors::magnitometer() const {
  // @@protoc_insertion_point(field_get:AmurSensors.magnitometer)
  return _internal_magnitometer();
}
inline ::AmurSensors_Magnitometer* AmurSensors::release_magnitometer() {
  // @@protoc_insertion_point(field_release:AmurSensors.magnitometer)
  
  ::AmurSensors_Magnitometer* temp = magnitometer_;
  magnitometer_ = nullptr;
  return temp;
}
inline ::AmurSensors_Magnitometer* AmurSensors::_internal_mutable_magnitometer() {
  
  if (magnitometer_ == nullptr) {
    auto* p = CreateMaybeMessage<::AmurSensors_Magnitometer>(GetArenaNoVirtual());
    magnitometer_ = p;
  }
  return magnitometer_;
}
inline ::AmurSensors_Magnitometer* AmurSensors::mutable_magnitometer() {
  // @@protoc_insertion_point(field_mutable:AmurSensors.magnitometer)
  return _internal_mutable_magnitometer();
}
inline void AmurSensors::set_allocated_magnitometer(::AmurSensors_Magnitometer* magnitometer) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete magnitometer_;
  }
  if (magnitometer) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      magnitometer = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, magnitometer, submessage_arena);
    }
    
  } else {
    
  }
  magnitometer_ = magnitometer;
  // @@protoc_insertion_point(field_set_allocated:AmurSensors.magnitometer)
}

// .AmurSensors.WheelEncoders wheelEncoders = 4;
inline bool AmurSensors::_internal_has_wheelencoders() const {
  return this != internal_default_instance() && wheelencoders_ != nullptr;
}
inline bool AmurSensors::has_wheelencoders() const {
  return _internal_has_wheelencoders();
}
inline void AmurSensors::clear_wheelencoders() {
  if (GetArenaNoVirtual() == nullptr && wheelencoders_ != nullptr) {
    delete wheelencoders_;
  }
  wheelencoders_ = nullptr;
}
inline const ::AmurSensors_WheelEncoders& AmurSensors::_internal_wheelencoders() const {
  const ::AmurSensors_WheelEncoders* p = wheelencoders_;
  return p != nullptr ? *p : *reinterpret_cast<const ::AmurSensors_WheelEncoders*>(
      &::_AmurSensors_WheelEncoders_default_instance_);
}
inline const ::AmurSensors_WheelEncoders& AmurSensors::wheelencoders() const {
  // @@protoc_insertion_point(field_get:AmurSensors.wheelEncoders)
  return _internal_wheelencoders();
}
inline ::AmurSensors_WheelEncoders* AmurSensors::release_wheelencoders() {
  // @@protoc_insertion_point(field_release:AmurSensors.wheelEncoders)
  
  ::AmurSensors_WheelEncoders* temp = wheelencoders_;
  wheelencoders_ = nullptr;
  return temp;
}
inline ::AmurSensors_WheelEncoders* AmurSensors::_internal_mutable_wheelencoders() {
  
  if (wheelencoders_ == nullptr) {
    auto* p = CreateMaybeMessage<::AmurSensors_WheelEncoders>(GetArenaNoVirtual());
    wheelencoders_ = p;
  }
  return wheelencoders_;
}
inline ::AmurSensors_WheelEncoders* AmurSensors::mutable_wheelencoders() {
  // @@protoc_insertion_point(field_mutable:AmurSensors.wheelEncoders)
  return _internal_mutable_wheelencoders();
}
inline void AmurSensors::set_allocated_wheelencoders(::AmurSensors_WheelEncoders* wheelencoders) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete wheelencoders_;
  }
  if (wheelencoders) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      wheelencoders = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wheelencoders, submessage_arena);
    }
    
  } else {
    
  }
  wheelencoders_ = wheelencoders;
  // @@protoc_insertion_point(field_set_allocated:AmurSensors.wheelEncoders)
}

// .AmurSensors.HandEncoders handEncoders = 5;
inline bool AmurSensors::_internal_has_handencoders() const {
  return this != internal_default_instance() && handencoders_ != nullptr;
}
inline bool AmurSensors::has_handencoders() const {
  return _internal_has_handencoders();
}
inline void AmurSensors::clear_handencoders() {
  if (GetArenaNoVirtual() == nullptr && handencoders_ != nullptr) {
    delete handencoders_;
  }
  handencoders_ = nullptr;
}
inline const ::AmurSensors_HandEncoders& AmurSensors::_internal_handencoders() const {
  const ::AmurSensors_HandEncoders* p = handencoders_;
  return p != nullptr ? *p : *reinterpret_cast<const ::AmurSensors_HandEncoders*>(
      &::_AmurSensors_HandEncoders_default_instance_);
}
inline const ::AmurSensors_HandEncoders& AmurSensors::handencoders() const {
  // @@protoc_insertion_point(field_get:AmurSensors.handEncoders)
  return _internal_handencoders();
}
inline ::AmurSensors_HandEncoders* AmurSensors::release_handencoders() {
  // @@protoc_insertion_point(field_release:AmurSensors.handEncoders)
  
  ::AmurSensors_HandEncoders* temp = handencoders_;
  handencoders_ = nullptr;
  return temp;
}
inline ::AmurSensors_HandEncoders* AmurSensors::_internal_mutable_handencoders() {
  
  if (handencoders_ == nullptr) {
    auto* p = CreateMaybeMessage<::AmurSensors_HandEncoders>(GetArenaNoVirtual());
    handencoders_ = p;
  }
  return handencoders_;
}
inline ::AmurSensors_HandEncoders* AmurSensors::mutable_handencoders() {
  // @@protoc_insertion_point(field_mutable:AmurSensors.handEncoders)
  return _internal_mutable_handencoders();
}
inline void AmurSensors::set_allocated_handencoders(::AmurSensors_HandEncoders* handencoders) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete handencoders_;
  }
  if (handencoders) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      handencoders = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handencoders, submessage_arena);
    }
    
  } else {
    
  }
  handencoders_ = handencoders;
  // @@protoc_insertion_point(field_set_allocated:AmurSensors.handEncoders)
}

// .AmurSensors.Temperature temperature = 6;
inline bool AmurSensors::_internal_has_temperature() const {
  return this != internal_default_instance() && temperature_ != nullptr;
}
inline bool AmurSensors::has_temperature() const {
  return _internal_has_temperature();
}
inline void AmurSensors::clear_temperature() {
  if (GetArenaNoVirtual() == nullptr && temperature_ != nullptr) {
    delete temperature_;
  }
  temperature_ = nullptr;
}
inline const ::AmurSensors_Temperature& AmurSensors::_internal_temperature() const {
  const ::AmurSensors_Temperature* p = temperature_;
  return p != nullptr ? *p : *reinterpret_cast<const ::AmurSensors_Temperature*>(
      &::_AmurSensors_Temperature_default_instance_);
}
inline const ::AmurSensors_Temperature& AmurSensors::temperature() const {
  // @@protoc_insertion_point(field_get:AmurSensors.temperature)
  return _internal_temperature();
}
inline ::AmurSensors_Temperature* AmurSensors::release_temperature() {
  // @@protoc_insertion_point(field_release:AmurSensors.temperature)
  
  ::AmurSensors_Temperature* temp = temperature_;
  temperature_ = nullptr;
  return temp;
}
inline ::AmurSensors_Temperature* AmurSensors::_internal_mutable_temperature() {
  
  if (temperature_ == nullptr) {
    auto* p = CreateMaybeMessage<::AmurSensors_Temperature>(GetArenaNoVirtual());
    temperature_ = p;
  }
  return temperature_;
}
inline ::AmurSensors_Temperature* AmurSensors::mutable_temperature() {
  // @@protoc_insertion_point(field_mutable:AmurSensors.temperature)
  return _internal_mutable_temperature();
}
inline void AmurSensors::set_allocated_temperature(::AmurSensors_Temperature* temperature) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete temperature_;
  }
  if (temperature) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      temperature = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, temperature, submessage_arena);
    }
    
  } else {
    
  }
  temperature_ = temperature;
  // @@protoc_insertion_point(field_set_allocated:AmurSensors.temperature)
}

// .AmurSensors.Misc misc = 7;
inline bool AmurSensors::_internal_has_misc() const {
  return this != internal_default_instance() && misc_ != nullptr;
}
inline bool AmurSensors::has_misc() const {
  return _internal_has_misc();
}
inline void AmurSensors::clear_misc() {
  if (GetArenaNoVirtual() == nullptr && misc_ != nullptr) {
    delete misc_;
  }
  misc_ = nullptr;
}
inline const ::AmurSensors_Misc& AmurSensors::_internal_misc() const {
  const ::AmurSensors_Misc* p = misc_;
  return p != nullptr ? *p : *reinterpret_cast<const ::AmurSensors_Misc*>(
      &::_AmurSensors_Misc_default_instance_);
}
inline const ::AmurSensors_Misc& AmurSensors::misc() const {
  // @@protoc_insertion_point(field_get:AmurSensors.misc)
  return _internal_misc();
}
inline ::AmurSensors_Misc* AmurSensors::release_misc() {
  // @@protoc_insertion_point(field_release:AmurSensors.misc)
  
  ::AmurSensors_Misc* temp = misc_;
  misc_ = nullptr;
  return temp;
}
inline ::AmurSensors_Misc* AmurSensors::_internal_mutable_misc() {
  
  if (misc_ == nullptr) {
    auto* p = CreateMaybeMessage<::AmurSensors_Misc>(GetArenaNoVirtual());
    misc_ = p;
  }
  return misc_;
}
inline ::AmurSensors_Misc* AmurSensors::mutable_misc() {
  // @@protoc_insertion_point(field_mutable:AmurSensors.misc)
  return _internal_mutable_misc();
}
inline void AmurSensors::set_allocated_misc(::AmurSensors_Misc* misc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete misc_;
  }
  if (misc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      misc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, misc, submessage_arena);
    }
    
  } else {
    
  }
  misc_ = misc;
  // @@protoc_insertion_point(field_set_allocated:AmurSensors.misc)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sensors_2eproto
