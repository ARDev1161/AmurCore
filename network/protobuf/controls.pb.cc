// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: controls.proto

#include "controls.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_controls_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurControls_CameraServos_controls_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_controls_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurControls_HandMotors_controls_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_controls_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurControls_Light_controls_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_controls_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurControls_System_controls_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_controls_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurControls_WheelMotors_controls_2eproto;
class AmurControls_CameraServosDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AmurControls_CameraServos> _instance;
} _AmurControls_CameraServos_default_instance_;
class AmurControls_WheelMotorsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AmurControls_WheelMotors> _instance;
} _AmurControls_WheelMotors_default_instance_;
class AmurControls_HandMotorsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AmurControls_HandMotors> _instance;
} _AmurControls_HandMotors_default_instance_;
class AmurControls_LightDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AmurControls_Light> _instance;
} _AmurControls_Light_default_instance_;
class AmurControls_SystemDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AmurControls_System> _instance;
} _AmurControls_System_default_instance_;
class AmurControlsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<AmurControls> _instance;
} _AmurControls_default_instance_;
static void InitDefaultsscc_info_AmurControls_controls_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_AmurControls_default_instance_;
    new (ptr) ::AmurControls();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::AmurControls::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<5> scc_info_AmurControls_controls_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 5, 0, InitDefaultsscc_info_AmurControls_controls_2eproto}, {
      &scc_info_AmurControls_CameraServos_controls_2eproto.base,
      &scc_info_AmurControls_WheelMotors_controls_2eproto.base,
      &scc_info_AmurControls_HandMotors_controls_2eproto.base,
      &scc_info_AmurControls_Light_controls_2eproto.base,
      &scc_info_AmurControls_System_controls_2eproto.base,}};

static void InitDefaultsscc_info_AmurControls_CameraServos_controls_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_AmurControls_CameraServos_default_instance_;
    new (ptr) ::AmurControls_CameraServos();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::AmurControls_CameraServos::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurControls_CameraServos_controls_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_AmurControls_CameraServos_controls_2eproto}, {}};

static void InitDefaultsscc_info_AmurControls_HandMotors_controls_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_AmurControls_HandMotors_default_instance_;
    new (ptr) ::AmurControls_HandMotors();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::AmurControls_HandMotors::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurControls_HandMotors_controls_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_AmurControls_HandMotors_controls_2eproto}, {}};

static void InitDefaultsscc_info_AmurControls_Light_controls_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_AmurControls_Light_default_instance_;
    new (ptr) ::AmurControls_Light();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::AmurControls_Light::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurControls_Light_controls_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_AmurControls_Light_controls_2eproto}, {}};

static void InitDefaultsscc_info_AmurControls_System_controls_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_AmurControls_System_default_instance_;
    new (ptr) ::AmurControls_System();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::AmurControls_System::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurControls_System_controls_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_AmurControls_System_controls_2eproto}, {}};

static void InitDefaultsscc_info_AmurControls_WheelMotors_controls_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::_AmurControls_WheelMotors_default_instance_;
    new (ptr) ::AmurControls_WheelMotors();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::AmurControls_WheelMotors::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_AmurControls_WheelMotors_controls_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, 0, InitDefaultsscc_info_AmurControls_WheelMotors_controls_2eproto}, {}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_controls_2eproto[6];
static constexpr ::PROTOBUF_NAMESPACE_ID::EnumDescriptor const** file_level_enum_descriptors_controls_2eproto = nullptr;
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_controls_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_controls_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AmurControls_CameraServos, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::AmurControls_CameraServos, xangle_),
  PROTOBUF_FIELD_OFFSET(::AmurControls_CameraServos, yangle_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AmurControls_WheelMotors, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::AmurControls_WheelMotors, leftpower_),
  PROTOBUF_FIELD_OFFSET(::AmurControls_WheelMotors, lefttime_),
  PROTOBUF_FIELD_OFFSET(::AmurControls_WheelMotors, rightpower_),
  PROTOBUF_FIELD_OFFSET(::AmurControls_WheelMotors, righttime_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AmurControls_HandMotors, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::AmurControls_HandMotors, leftpower_),
  PROTOBUF_FIELD_OFFSET(::AmurControls_HandMotors, lefttime_),
  PROTOBUF_FIELD_OFFSET(::AmurControls_HandMotors, rightpower_),
  PROTOBUF_FIELD_OFFSET(::AmurControls_HandMotors, righttime_),
  PROTOBUF_FIELD_OFFSET(::AmurControls_HandMotors, leftrelay_),
  PROTOBUF_FIELD_OFFSET(::AmurControls_HandMotors, rightrelay_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AmurControls_Light, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::AmurControls_Light, ledleftpower_),
  PROTOBUF_FIELD_OFFSET(::AmurControls_Light, ledrightpower_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AmurControls_System, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::AmurControls_System, haltflag_),
  PROTOBUF_FIELD_OFFSET(::AmurControls_System, restartflag_),
  PROTOBUF_FIELD_OFFSET(::AmurControls_System, timeonamur_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::AmurControls, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::AmurControls, cameraservos_),
  PROTOBUF_FIELD_OFFSET(::AmurControls, wheelmotors_),
  PROTOBUF_FIELD_OFFSET(::AmurControls, handmotors_),
  PROTOBUF_FIELD_OFFSET(::AmurControls, light_),
  PROTOBUF_FIELD_OFFSET(::AmurControls, system_),
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, -1, sizeof(::AmurControls_CameraServos)},
  { 7, -1, sizeof(::AmurControls_WheelMotors)},
  { 16, -1, sizeof(::AmurControls_HandMotors)},
  { 27, -1, sizeof(::AmurControls_Light)},
  { 34, -1, sizeof(::AmurControls_System)},
  { 42, -1, sizeof(::AmurControls)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_AmurControls_CameraServos_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_AmurControls_WheelMotors_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_AmurControls_HandMotors_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_AmurControls_Light_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_AmurControls_System_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::_AmurControls_default_instance_),
};

const char descriptor_table_protodef_controls_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\016controls.proto\"\357\004\n\014AmurControls\0220\n\014cam"
  "eraServos\030\001 \001(\0132\032.AmurControls.CameraSer"
  "vos\022.\n\013wheelMotors\030\002 \001(\0132\031.AmurControls."
  "WheelMotors\022,\n\nhandMotors\030\003 \001(\0132\030.AmurCo"
  "ntrols.HandMotors\022\"\n\005light\030\004 \001(\0132\023.AmurC"
  "ontrols.Light\022$\n\006system\030\005 \001(\0132\024.AmurCont"
  "rols.System\032.\n\014CameraServos\022\016\n\006xAngle\030\001 "
  "\001(\005\022\016\n\006yAngle\030\002 \001(\005\032Y\n\013WheelMotors\022\021\n\tle"
  "ftPower\030\001 \001(\005\022\020\n\010leftTime\030\002 \001(\005\022\022\n\nright"
  "Power\030\003 \001(\005\022\021\n\trightTime\030\004 \001(\005\032\177\n\nHandMo"
  "tors\022\021\n\tleftPower\030\001 \001(\005\022\020\n\010leftTime\030\002 \001("
  "\005\022\022\n\nrightPower\030\003 \001(\005\022\021\n\trightTime\030\004 \001(\005"
  "\022\021\n\tleftRelay\030\005 \001(\010\022\022\n\nrightRelay\030\006 \001(\010\032"
  "4\n\005Light\022\024\n\014ledLeftPower\030\001 \001(\005\022\025\n\rledRig"
  "htPower\030\002 \001(\005\032C\n\006System\022\020\n\010haltFlag\030\001 \001("
  "\010\022\023\n\013restartFlag\030\002 \001(\010\022\022\n\ntimeOnAmur\030\003 \001"
  "(\tb\006proto3"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_controls_2eproto_deps[1] = {
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_controls_2eproto_sccs[6] = {
  &scc_info_AmurControls_controls_2eproto.base,
  &scc_info_AmurControls_CameraServos_controls_2eproto.base,
  &scc_info_AmurControls_HandMotors_controls_2eproto.base,
  &scc_info_AmurControls_Light_controls_2eproto.base,
  &scc_info_AmurControls_System_controls_2eproto.base,
  &scc_info_AmurControls_WheelMotors_controls_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_controls_2eproto_once;
static bool descriptor_table_controls_2eproto_initialized = false;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_controls_2eproto = {
  &descriptor_table_controls_2eproto_initialized, descriptor_table_protodef_controls_2eproto, "controls.proto", 650,
  &descriptor_table_controls_2eproto_once, descriptor_table_controls_2eproto_sccs, descriptor_table_controls_2eproto_deps, 6, 0,
  schemas, file_default_instances, TableStruct_controls_2eproto::offsets,
  file_level_metadata_controls_2eproto, 6, file_level_enum_descriptors_controls_2eproto, file_level_service_descriptors_controls_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_controls_2eproto = (  ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_controls_2eproto), true);

// ===================================================================

void AmurControls_CameraServos::InitAsDefaultInstance() {
}
class AmurControls_CameraServos::_Internal {
 public:
};

AmurControls_CameraServos::AmurControls_CameraServos()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:AmurControls.CameraServos)
}
AmurControls_CameraServos::AmurControls_CameraServos(const AmurControls_CameraServos& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&xangle_, &from.xangle_,
    static_cast<size_t>(reinterpret_cast<char*>(&yangle_) -
    reinterpret_cast<char*>(&xangle_)) + sizeof(yangle_));
  // @@protoc_insertion_point(copy_constructor:AmurControls.CameraServos)
}

void AmurControls_CameraServos::SharedCtor() {
  ::memset(&xangle_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&yangle_) -
      reinterpret_cast<char*>(&xangle_)) + sizeof(yangle_));
}

AmurControls_CameraServos::~AmurControls_CameraServos() {
  // @@protoc_insertion_point(destructor:AmurControls.CameraServos)
  SharedDtor();
}

void AmurControls_CameraServos::SharedDtor() {
}

void AmurControls_CameraServos::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AmurControls_CameraServos& AmurControls_CameraServos::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AmurControls_CameraServos_controls_2eproto.base);
  return *internal_default_instance();
}


void AmurControls_CameraServos::Clear() {
// @@protoc_insertion_point(message_clear_start:AmurControls.CameraServos)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&xangle_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&yangle_) -
      reinterpret_cast<char*>(&xangle_)) + sizeof(yangle_));
  _internal_metadata_.Clear();
}

const char* AmurControls_CameraServos::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // int32 xAngle = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          xangle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 yAngle = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          yangle_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AmurControls_CameraServos::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AmurControls.CameraServos)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 xAngle = 1;
  if (this->xangle() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_xangle(), target);
  }

  // int32 yAngle = 2;
  if (this->yangle() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_yangle(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AmurControls.CameraServos)
  return target;
}

size_t AmurControls_CameraServos::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AmurControls.CameraServos)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 xAngle = 1;
  if (this->xangle() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_xangle());
  }

  // int32 yAngle = 2;
  if (this->yangle() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_yangle());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AmurControls_CameraServos::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:AmurControls.CameraServos)
  GOOGLE_DCHECK_NE(&from, this);
  const AmurControls_CameraServos* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AmurControls_CameraServos>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:AmurControls.CameraServos)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:AmurControls.CameraServos)
    MergeFrom(*source);
  }
}

void AmurControls_CameraServos::MergeFrom(const AmurControls_CameraServos& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AmurControls.CameraServos)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.xangle() != 0) {
    _internal_set_xangle(from._internal_xangle());
  }
  if (from.yangle() != 0) {
    _internal_set_yangle(from._internal_yangle());
  }
}

void AmurControls_CameraServos::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:AmurControls.CameraServos)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AmurControls_CameraServos::CopyFrom(const AmurControls_CameraServos& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AmurControls.CameraServos)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AmurControls_CameraServos::IsInitialized() const {
  return true;
}

void AmurControls_CameraServos::InternalSwap(AmurControls_CameraServos* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(xangle_, other->xangle_);
  swap(yangle_, other->yangle_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AmurControls_CameraServos::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AmurControls_WheelMotors::InitAsDefaultInstance() {
}
class AmurControls_WheelMotors::_Internal {
 public:
};

AmurControls_WheelMotors::AmurControls_WheelMotors()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:AmurControls.WheelMotors)
}
AmurControls_WheelMotors::AmurControls_WheelMotors(const AmurControls_WheelMotors& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&leftpower_, &from.leftpower_,
    static_cast<size_t>(reinterpret_cast<char*>(&righttime_) -
    reinterpret_cast<char*>(&leftpower_)) + sizeof(righttime_));
  // @@protoc_insertion_point(copy_constructor:AmurControls.WheelMotors)
}

void AmurControls_WheelMotors::SharedCtor() {
  ::memset(&leftpower_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&righttime_) -
      reinterpret_cast<char*>(&leftpower_)) + sizeof(righttime_));
}

AmurControls_WheelMotors::~AmurControls_WheelMotors() {
  // @@protoc_insertion_point(destructor:AmurControls.WheelMotors)
  SharedDtor();
}

void AmurControls_WheelMotors::SharedDtor() {
}

void AmurControls_WheelMotors::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AmurControls_WheelMotors& AmurControls_WheelMotors::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AmurControls_WheelMotors_controls_2eproto.base);
  return *internal_default_instance();
}


void AmurControls_WheelMotors::Clear() {
// @@protoc_insertion_point(message_clear_start:AmurControls.WheelMotors)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&leftpower_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&righttime_) -
      reinterpret_cast<char*>(&leftpower_)) + sizeof(righttime_));
  _internal_metadata_.Clear();
}

const char* AmurControls_WheelMotors::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // int32 leftPower = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          leftpower_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 leftTime = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          lefttime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 rightPower = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          rightpower_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 rightTime = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          righttime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AmurControls_WheelMotors::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AmurControls.WheelMotors)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 leftPower = 1;
  if (this->leftpower() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_leftpower(), target);
  }

  // int32 leftTime = 2;
  if (this->lefttime() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_lefttime(), target);
  }

  // int32 rightPower = 3;
  if (this->rightpower() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_rightpower(), target);
  }

  // int32 rightTime = 4;
  if (this->righttime() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_righttime(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AmurControls.WheelMotors)
  return target;
}

size_t AmurControls_WheelMotors::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AmurControls.WheelMotors)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 leftPower = 1;
  if (this->leftpower() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_leftpower());
  }

  // int32 leftTime = 2;
  if (this->lefttime() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_lefttime());
  }

  // int32 rightPower = 3;
  if (this->rightpower() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_rightpower());
  }

  // int32 rightTime = 4;
  if (this->righttime() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_righttime());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AmurControls_WheelMotors::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:AmurControls.WheelMotors)
  GOOGLE_DCHECK_NE(&from, this);
  const AmurControls_WheelMotors* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AmurControls_WheelMotors>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:AmurControls.WheelMotors)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:AmurControls.WheelMotors)
    MergeFrom(*source);
  }
}

void AmurControls_WheelMotors::MergeFrom(const AmurControls_WheelMotors& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AmurControls.WheelMotors)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.leftpower() != 0) {
    _internal_set_leftpower(from._internal_leftpower());
  }
  if (from.lefttime() != 0) {
    _internal_set_lefttime(from._internal_lefttime());
  }
  if (from.rightpower() != 0) {
    _internal_set_rightpower(from._internal_rightpower());
  }
  if (from.righttime() != 0) {
    _internal_set_righttime(from._internal_righttime());
  }
}

void AmurControls_WheelMotors::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:AmurControls.WheelMotors)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AmurControls_WheelMotors::CopyFrom(const AmurControls_WheelMotors& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AmurControls.WheelMotors)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AmurControls_WheelMotors::IsInitialized() const {
  return true;
}

void AmurControls_WheelMotors::InternalSwap(AmurControls_WheelMotors* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(leftpower_, other->leftpower_);
  swap(lefttime_, other->lefttime_);
  swap(rightpower_, other->rightpower_);
  swap(righttime_, other->righttime_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AmurControls_WheelMotors::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AmurControls_HandMotors::InitAsDefaultInstance() {
}
class AmurControls_HandMotors::_Internal {
 public:
};

AmurControls_HandMotors::AmurControls_HandMotors()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:AmurControls.HandMotors)
}
AmurControls_HandMotors::AmurControls_HandMotors(const AmurControls_HandMotors& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&leftpower_, &from.leftpower_,
    static_cast<size_t>(reinterpret_cast<char*>(&rightrelay_) -
    reinterpret_cast<char*>(&leftpower_)) + sizeof(rightrelay_));
  // @@protoc_insertion_point(copy_constructor:AmurControls.HandMotors)
}

void AmurControls_HandMotors::SharedCtor() {
  ::memset(&leftpower_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&rightrelay_) -
      reinterpret_cast<char*>(&leftpower_)) + sizeof(rightrelay_));
}

AmurControls_HandMotors::~AmurControls_HandMotors() {
  // @@protoc_insertion_point(destructor:AmurControls.HandMotors)
  SharedDtor();
}

void AmurControls_HandMotors::SharedDtor() {
}

void AmurControls_HandMotors::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AmurControls_HandMotors& AmurControls_HandMotors::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AmurControls_HandMotors_controls_2eproto.base);
  return *internal_default_instance();
}


void AmurControls_HandMotors::Clear() {
// @@protoc_insertion_point(message_clear_start:AmurControls.HandMotors)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&leftpower_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&rightrelay_) -
      reinterpret_cast<char*>(&leftpower_)) + sizeof(rightrelay_));
  _internal_metadata_.Clear();
}

const char* AmurControls_HandMotors::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // int32 leftPower = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          leftpower_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 leftTime = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          lefttime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 rightPower = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          rightpower_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 rightTime = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          righttime_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool leftRelay = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          leftrelay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool rightRelay = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          rightrelay_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AmurControls_HandMotors::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AmurControls.HandMotors)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 leftPower = 1;
  if (this->leftpower() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_leftpower(), target);
  }

  // int32 leftTime = 2;
  if (this->lefttime() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_lefttime(), target);
  }

  // int32 rightPower = 3;
  if (this->rightpower() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(3, this->_internal_rightpower(), target);
  }

  // int32 rightTime = 4;
  if (this->righttime() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(4, this->_internal_righttime(), target);
  }

  // bool leftRelay = 5;
  if (this->leftrelay() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(5, this->_internal_leftrelay(), target);
  }

  // bool rightRelay = 6;
  if (this->rightrelay() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(6, this->_internal_rightrelay(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AmurControls.HandMotors)
  return target;
}

size_t AmurControls_HandMotors::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AmurControls.HandMotors)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 leftPower = 1;
  if (this->leftpower() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_leftpower());
  }

  // int32 leftTime = 2;
  if (this->lefttime() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_lefttime());
  }

  // int32 rightPower = 3;
  if (this->rightpower() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_rightpower());
  }

  // int32 rightTime = 4;
  if (this->righttime() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_righttime());
  }

  // bool leftRelay = 5;
  if (this->leftrelay() != 0) {
    total_size += 1 + 1;
  }

  // bool rightRelay = 6;
  if (this->rightrelay() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AmurControls_HandMotors::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:AmurControls.HandMotors)
  GOOGLE_DCHECK_NE(&from, this);
  const AmurControls_HandMotors* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AmurControls_HandMotors>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:AmurControls.HandMotors)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:AmurControls.HandMotors)
    MergeFrom(*source);
  }
}

void AmurControls_HandMotors::MergeFrom(const AmurControls_HandMotors& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AmurControls.HandMotors)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.leftpower() != 0) {
    _internal_set_leftpower(from._internal_leftpower());
  }
  if (from.lefttime() != 0) {
    _internal_set_lefttime(from._internal_lefttime());
  }
  if (from.rightpower() != 0) {
    _internal_set_rightpower(from._internal_rightpower());
  }
  if (from.righttime() != 0) {
    _internal_set_righttime(from._internal_righttime());
  }
  if (from.leftrelay() != 0) {
    _internal_set_leftrelay(from._internal_leftrelay());
  }
  if (from.rightrelay() != 0) {
    _internal_set_rightrelay(from._internal_rightrelay());
  }
}

void AmurControls_HandMotors::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:AmurControls.HandMotors)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AmurControls_HandMotors::CopyFrom(const AmurControls_HandMotors& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AmurControls.HandMotors)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AmurControls_HandMotors::IsInitialized() const {
  return true;
}

void AmurControls_HandMotors::InternalSwap(AmurControls_HandMotors* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(leftpower_, other->leftpower_);
  swap(lefttime_, other->lefttime_);
  swap(rightpower_, other->rightpower_);
  swap(righttime_, other->righttime_);
  swap(leftrelay_, other->leftrelay_);
  swap(rightrelay_, other->rightrelay_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AmurControls_HandMotors::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AmurControls_Light::InitAsDefaultInstance() {
}
class AmurControls_Light::_Internal {
 public:
};

AmurControls_Light::AmurControls_Light()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:AmurControls.Light)
}
AmurControls_Light::AmurControls_Light(const AmurControls_Light& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&ledleftpower_, &from.ledleftpower_,
    static_cast<size_t>(reinterpret_cast<char*>(&ledrightpower_) -
    reinterpret_cast<char*>(&ledleftpower_)) + sizeof(ledrightpower_));
  // @@protoc_insertion_point(copy_constructor:AmurControls.Light)
}

void AmurControls_Light::SharedCtor() {
  ::memset(&ledleftpower_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ledrightpower_) -
      reinterpret_cast<char*>(&ledleftpower_)) + sizeof(ledrightpower_));
}

AmurControls_Light::~AmurControls_Light() {
  // @@protoc_insertion_point(destructor:AmurControls.Light)
  SharedDtor();
}

void AmurControls_Light::SharedDtor() {
}

void AmurControls_Light::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AmurControls_Light& AmurControls_Light::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AmurControls_Light_controls_2eproto.base);
  return *internal_default_instance();
}


void AmurControls_Light::Clear() {
// @@protoc_insertion_point(message_clear_start:AmurControls.Light)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  ::memset(&ledleftpower_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&ledrightpower_) -
      reinterpret_cast<char*>(&ledleftpower_)) + sizeof(ledrightpower_));
  _internal_metadata_.Clear();
}

const char* AmurControls_Light::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // int32 ledLeftPower = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ledleftpower_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // int32 ledRightPower = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ledrightpower_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AmurControls_Light::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AmurControls.Light)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 ledLeftPower = 1;
  if (this->ledleftpower() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(1, this->_internal_ledleftpower(), target);
  }

  // int32 ledRightPower = 2;
  if (this->ledrightpower() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteInt32ToArray(2, this->_internal_ledrightpower(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AmurControls.Light)
  return target;
}

size_t AmurControls_Light::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AmurControls.Light)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // int32 ledLeftPower = 1;
  if (this->ledleftpower() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_ledleftpower());
  }

  // int32 ledRightPower = 2;
  if (this->ledrightpower() != 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::Int32Size(
        this->_internal_ledrightpower());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AmurControls_Light::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:AmurControls.Light)
  GOOGLE_DCHECK_NE(&from, this);
  const AmurControls_Light* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AmurControls_Light>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:AmurControls.Light)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:AmurControls.Light)
    MergeFrom(*source);
  }
}

void AmurControls_Light::MergeFrom(const AmurControls_Light& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AmurControls.Light)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.ledleftpower() != 0) {
    _internal_set_ledleftpower(from._internal_ledleftpower());
  }
  if (from.ledrightpower() != 0) {
    _internal_set_ledrightpower(from._internal_ledrightpower());
  }
}

void AmurControls_Light::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:AmurControls.Light)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AmurControls_Light::CopyFrom(const AmurControls_Light& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AmurControls.Light)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AmurControls_Light::IsInitialized() const {
  return true;
}

void AmurControls_Light::InternalSwap(AmurControls_Light* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(ledleftpower_, other->ledleftpower_);
  swap(ledrightpower_, other->ledrightpower_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AmurControls_Light::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AmurControls_System::InitAsDefaultInstance() {
}
class AmurControls_System::_Internal {
 public:
};

AmurControls_System::AmurControls_System()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:AmurControls.System)
}
AmurControls_System::AmurControls_System(const AmurControls_System& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  timeonamur_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (!from._internal_timeonamur().empty()) {
    timeonamur_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.timeonamur_);
  }
  ::memcpy(&haltflag_, &from.haltflag_,
    static_cast<size_t>(reinterpret_cast<char*>(&restartflag_) -
    reinterpret_cast<char*>(&haltflag_)) + sizeof(restartflag_));
  // @@protoc_insertion_point(copy_constructor:AmurControls.System)
}

void AmurControls_System::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AmurControls_System_controls_2eproto.base);
  timeonamur_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&haltflag_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&restartflag_) -
      reinterpret_cast<char*>(&haltflag_)) + sizeof(restartflag_));
}

AmurControls_System::~AmurControls_System() {
  // @@protoc_insertion_point(destructor:AmurControls.System)
  SharedDtor();
}

void AmurControls_System::SharedDtor() {
  timeonamur_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void AmurControls_System::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AmurControls_System& AmurControls_System::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AmurControls_System_controls_2eproto.base);
  return *internal_default_instance();
}


void AmurControls_System::Clear() {
// @@protoc_insertion_point(message_clear_start:AmurControls.System)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  timeonamur_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&haltflag_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&restartflag_) -
      reinterpret_cast<char*>(&haltflag_)) + sizeof(restartflag_));
  _internal_metadata_.Clear();
}

const char* AmurControls_System::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // bool haltFlag = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          haltflag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // bool restartFlag = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          restartflag_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // string timeOnAmur = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          auto str = _internal_mutable_timeonamur();
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(::PROTOBUF_NAMESPACE_ID::internal::VerifyUTF8(str, "AmurControls.System.timeOnAmur"));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AmurControls_System::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AmurControls.System)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // bool haltFlag = 1;
  if (this->haltflag() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(1, this->_internal_haltflag(), target);
  }

  // bool restartFlag = 2;
  if (this->restartflag() != 0) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBoolToArray(2, this->_internal_restartflag(), target);
  }

  // string timeOnAmur = 3;
  if (this->timeonamur().size() > 0) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_timeonamur().data(), static_cast<int>(this->_internal_timeonamur().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "AmurControls.System.timeOnAmur");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_timeonamur(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AmurControls.System)
  return target;
}

size_t AmurControls_System::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AmurControls.System)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string timeOnAmur = 3;
  if (this->timeonamur().size() > 0) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_timeonamur());
  }

  // bool haltFlag = 1;
  if (this->haltflag() != 0) {
    total_size += 1 + 1;
  }

  // bool restartFlag = 2;
  if (this->restartflag() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AmurControls_System::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:AmurControls.System)
  GOOGLE_DCHECK_NE(&from, this);
  const AmurControls_System* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AmurControls_System>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:AmurControls.System)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:AmurControls.System)
    MergeFrom(*source);
  }
}

void AmurControls_System::MergeFrom(const AmurControls_System& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AmurControls.System)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.timeonamur().size() > 0) {

    timeonamur_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.timeonamur_);
  }
  if (from.haltflag() != 0) {
    _internal_set_haltflag(from._internal_haltflag());
  }
  if (from.restartflag() != 0) {
    _internal_set_restartflag(from._internal_restartflag());
  }
}

void AmurControls_System::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:AmurControls.System)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AmurControls_System::CopyFrom(const AmurControls_System& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AmurControls.System)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AmurControls_System::IsInitialized() const {
  return true;
}

void AmurControls_System::InternalSwap(AmurControls_System* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  timeonamur_.Swap(&other->timeonamur_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(haltflag_, other->haltflag_);
  swap(restartflag_, other->restartflag_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AmurControls_System::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void AmurControls::InitAsDefaultInstance() {
  ::_AmurControls_default_instance_._instance.get_mutable()->cameraservos_ = const_cast< ::AmurControls_CameraServos*>(
      ::AmurControls_CameraServos::internal_default_instance());
  ::_AmurControls_default_instance_._instance.get_mutable()->wheelmotors_ = const_cast< ::AmurControls_WheelMotors*>(
      ::AmurControls_WheelMotors::internal_default_instance());
  ::_AmurControls_default_instance_._instance.get_mutable()->handmotors_ = const_cast< ::AmurControls_HandMotors*>(
      ::AmurControls_HandMotors::internal_default_instance());
  ::_AmurControls_default_instance_._instance.get_mutable()->light_ = const_cast< ::AmurControls_Light*>(
      ::AmurControls_Light::internal_default_instance());
  ::_AmurControls_default_instance_._instance.get_mutable()->system_ = const_cast< ::AmurControls_System*>(
      ::AmurControls_System::internal_default_instance());
}
class AmurControls::_Internal {
 public:
  static const ::AmurControls_CameraServos& cameraservos(const AmurControls* msg);
  static const ::AmurControls_WheelMotors& wheelmotors(const AmurControls* msg);
  static const ::AmurControls_HandMotors& handmotors(const AmurControls* msg);
  static const ::AmurControls_Light& light(const AmurControls* msg);
  static const ::AmurControls_System& system(const AmurControls* msg);
};

const ::AmurControls_CameraServos&
AmurControls::_Internal::cameraservos(const AmurControls* msg) {
  return *msg->cameraservos_;
}
const ::AmurControls_WheelMotors&
AmurControls::_Internal::wheelmotors(const AmurControls* msg) {
  return *msg->wheelmotors_;
}
const ::AmurControls_HandMotors&
AmurControls::_Internal::handmotors(const AmurControls* msg) {
  return *msg->handmotors_;
}
const ::AmurControls_Light&
AmurControls::_Internal::light(const AmurControls* msg) {
  return *msg->light_;
}
const ::AmurControls_System&
AmurControls::_Internal::system(const AmurControls* msg) {
  return *msg->system_;
}
AmurControls::AmurControls()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:AmurControls)
}
AmurControls::AmurControls(const AmurControls& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from._internal_has_cameraservos()) {
    cameraservos_ = new ::AmurControls_CameraServos(*from.cameraservos_);
  } else {
    cameraservos_ = nullptr;
  }
  if (from._internal_has_wheelmotors()) {
    wheelmotors_ = new ::AmurControls_WheelMotors(*from.wheelmotors_);
  } else {
    wheelmotors_ = nullptr;
  }
  if (from._internal_has_handmotors()) {
    handmotors_ = new ::AmurControls_HandMotors(*from.handmotors_);
  } else {
    handmotors_ = nullptr;
  }
  if (from._internal_has_light()) {
    light_ = new ::AmurControls_Light(*from.light_);
  } else {
    light_ = nullptr;
  }
  if (from._internal_has_system()) {
    system_ = new ::AmurControls_System(*from.system_);
  } else {
    system_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:AmurControls)
}

void AmurControls::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_AmurControls_controls_2eproto.base);
  ::memset(&cameraservos_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&system_) -
      reinterpret_cast<char*>(&cameraservos_)) + sizeof(system_));
}

AmurControls::~AmurControls() {
  // @@protoc_insertion_point(destructor:AmurControls)
  SharedDtor();
}

void AmurControls::SharedDtor() {
  if (this != internal_default_instance()) delete cameraservos_;
  if (this != internal_default_instance()) delete wheelmotors_;
  if (this != internal_default_instance()) delete handmotors_;
  if (this != internal_default_instance()) delete light_;
  if (this != internal_default_instance()) delete system_;
}

void AmurControls::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const AmurControls& AmurControls::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_AmurControls_controls_2eproto.base);
  return *internal_default_instance();
}


void AmurControls::Clear() {
// @@protoc_insertion_point(message_clear_start:AmurControls)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaNoVirtual() == nullptr && cameraservos_ != nullptr) {
    delete cameraservos_;
  }
  cameraservos_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && wheelmotors_ != nullptr) {
    delete wheelmotors_;
  }
  wheelmotors_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && handmotors_ != nullptr) {
    delete handmotors_;
  }
  handmotors_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && light_ != nullptr) {
    delete light_;
  }
  light_ = nullptr;
  if (GetArenaNoVirtual() == nullptr && system_ != nullptr) {
    delete system_;
  }
  system_ = nullptr;
  _internal_metadata_.Clear();
}

const char* AmurControls::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // .AmurControls.CameraServos cameraServos = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_cameraservos(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .AmurControls.WheelMotors wheelMotors = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_wheelmotors(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .AmurControls.HandMotors handMotors = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_handmotors(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .AmurControls.Light light = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(_internal_mutable_light(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // .AmurControls.System system = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_system(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}

::PROTOBUF_NAMESPACE_ID::uint8* AmurControls::_InternalSerialize(
    ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:AmurControls)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // .AmurControls.CameraServos cameraServos = 1;
  if (this->has_cameraservos()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        1, _Internal::cameraservos(this), target, stream);
  }

  // .AmurControls.WheelMotors wheelMotors = 2;
  if (this->has_wheelmotors()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        2, _Internal::wheelmotors(this), target, stream);
  }

  // .AmurControls.HandMotors handMotors = 3;
  if (this->has_handmotors()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        3, _Internal::handmotors(this), target, stream);
  }

  // .AmurControls.Light light = 4;
  if (this->has_light()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        4, _Internal::light(this), target, stream);
  }

  // .AmurControls.System system = 5;
  if (this->has_system()) {
    target = stream->EnsureSpace(target);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(
        5, _Internal::system(this), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AmurControls)
  return target;
}

size_t AmurControls::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:AmurControls)
  size_t total_size = 0;

  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .AmurControls.CameraServos cameraServos = 1;
  if (this->has_cameraservos()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *cameraservos_);
  }

  // .AmurControls.WheelMotors wheelMotors = 2;
  if (this->has_wheelmotors()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *wheelmotors_);
  }

  // .AmurControls.HandMotors handMotors = 3;
  if (this->has_handmotors()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *handmotors_);
  }

  // .AmurControls.Light light = 4;
  if (this->has_light()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *light_);
  }

  // .AmurControls.System system = 5;
  if (this->has_system()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *system_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    return ::PROTOBUF_NAMESPACE_ID::internal::ComputeUnknownFieldsSize(
        _internal_metadata_, total_size, &_cached_size_);
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void AmurControls::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:AmurControls)
  GOOGLE_DCHECK_NE(&from, this);
  const AmurControls* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<AmurControls>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:AmurControls)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:AmurControls)
    MergeFrom(*source);
  }
}

void AmurControls::MergeFrom(const AmurControls& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:AmurControls)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_cameraservos()) {
    _internal_mutable_cameraservos()->::AmurControls_CameraServos::MergeFrom(from._internal_cameraservos());
  }
  if (from.has_wheelmotors()) {
    _internal_mutable_wheelmotors()->::AmurControls_WheelMotors::MergeFrom(from._internal_wheelmotors());
  }
  if (from.has_handmotors()) {
    _internal_mutable_handmotors()->::AmurControls_HandMotors::MergeFrom(from._internal_handmotors());
  }
  if (from.has_light()) {
    _internal_mutable_light()->::AmurControls_Light::MergeFrom(from._internal_light());
  }
  if (from.has_system()) {
    _internal_mutable_system()->::AmurControls_System::MergeFrom(from._internal_system());
  }
}

void AmurControls::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:AmurControls)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AmurControls::CopyFrom(const AmurControls& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:AmurControls)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AmurControls::IsInitialized() const {
  return true;
}

void AmurControls::InternalSwap(AmurControls* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(cameraservos_, other->cameraservos_);
  swap(wheelmotors_, other->wheelmotors_);
  swap(handmotors_, other->handmotors_);
  swap(light_, other->light_);
  swap(system_, other->system_);
}

::PROTOBUF_NAMESPACE_ID::Metadata AmurControls::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::AmurControls_CameraServos* Arena::CreateMaybeMessage< ::AmurControls_CameraServos >(Arena* arena) {
  return Arena::CreateInternal< ::AmurControls_CameraServos >(arena);
}
template<> PROTOBUF_NOINLINE ::AmurControls_WheelMotors* Arena::CreateMaybeMessage< ::AmurControls_WheelMotors >(Arena* arena) {
  return Arena::CreateInternal< ::AmurControls_WheelMotors >(arena);
}
template<> PROTOBUF_NOINLINE ::AmurControls_HandMotors* Arena::CreateMaybeMessage< ::AmurControls_HandMotors >(Arena* arena) {
  return Arena::CreateInternal< ::AmurControls_HandMotors >(arena);
}
template<> PROTOBUF_NOINLINE ::AmurControls_Light* Arena::CreateMaybeMessage< ::AmurControls_Light >(Arena* arena) {
  return Arena::CreateInternal< ::AmurControls_Light >(arena);
}
template<> PROTOBUF_NOINLINE ::AmurControls_System* Arena::CreateMaybeMessage< ::AmurControls_System >(Arena* arena) {
  return Arena::CreateInternal< ::AmurControls_System >(arena);
}
template<> PROTOBUF_NOINLINE ::AmurControls* Arena::CreateMaybeMessage< ::AmurControls >(Arena* arena) {
  return Arena::CreateInternal< ::AmurControls >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
