// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: controls.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_controls_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_controls_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3011000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3011004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_controls_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_controls_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_controls_2eproto;
class AmurControls;
class AmurControlsDefaultTypeInternal;
extern AmurControlsDefaultTypeInternal _AmurControls_default_instance_;
class AmurControls_CameraServos;
class AmurControls_CameraServosDefaultTypeInternal;
extern AmurControls_CameraServosDefaultTypeInternal _AmurControls_CameraServos_default_instance_;
class AmurControls_HandMotors;
class AmurControls_HandMotorsDefaultTypeInternal;
extern AmurControls_HandMotorsDefaultTypeInternal _AmurControls_HandMotors_default_instance_;
class AmurControls_Light;
class AmurControls_LightDefaultTypeInternal;
extern AmurControls_LightDefaultTypeInternal _AmurControls_Light_default_instance_;
class AmurControls_System;
class AmurControls_SystemDefaultTypeInternal;
extern AmurControls_SystemDefaultTypeInternal _AmurControls_System_default_instance_;
class AmurControls_WheelMotors;
class AmurControls_WheelMotorsDefaultTypeInternal;
extern AmurControls_WheelMotorsDefaultTypeInternal _AmurControls_WheelMotors_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::AmurControls* Arena::CreateMaybeMessage<::AmurControls>(Arena*);
template<> ::AmurControls_CameraServos* Arena::CreateMaybeMessage<::AmurControls_CameraServos>(Arena*);
template<> ::AmurControls_HandMotors* Arena::CreateMaybeMessage<::AmurControls_HandMotors>(Arena*);
template<> ::AmurControls_Light* Arena::CreateMaybeMessage<::AmurControls_Light>(Arena*);
template<> ::AmurControls_System* Arena::CreateMaybeMessage<::AmurControls_System>(Arena*);
template<> ::AmurControls_WheelMotors* Arena::CreateMaybeMessage<::AmurControls_WheelMotors>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class AmurControls_CameraServos :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AmurControls.CameraServos) */ {
 public:
  AmurControls_CameraServos();
  virtual ~AmurControls_CameraServos();

  AmurControls_CameraServos(const AmurControls_CameraServos& from);
  AmurControls_CameraServos(AmurControls_CameraServos&& from) noexcept
    : AmurControls_CameraServos() {
    *this = ::std::move(from);
  }

  inline AmurControls_CameraServos& operator=(const AmurControls_CameraServos& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurControls_CameraServos& operator=(AmurControls_CameraServos&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurControls_CameraServos& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurControls_CameraServos* internal_default_instance() {
    return reinterpret_cast<const AmurControls_CameraServos*>(
               &_AmurControls_CameraServos_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(AmurControls_CameraServos& a, AmurControls_CameraServos& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurControls_CameraServos* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurControls_CameraServos* New() const final {
    return CreateMaybeMessage<AmurControls_CameraServos>(nullptr);
  }

  AmurControls_CameraServos* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurControls_CameraServos>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurControls_CameraServos& from);
  void MergeFrom(const AmurControls_CameraServos& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurControls_CameraServos* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AmurControls.CameraServos";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_controls_2eproto);
    return ::descriptor_table_controls_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kXAngleFieldNumber = 1,
    kYAngleFieldNumber = 2,
  };
  // int32 xAngle = 1;
  void clear_xangle();
  ::PROTOBUF_NAMESPACE_ID::int32 xangle() const;
  void set_xangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_xangle() const;
  void _internal_set_xangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 yAngle = 2;
  void clear_yangle();
  ::PROTOBUF_NAMESPACE_ID::int32 yangle() const;
  void set_yangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_yangle() const;
  void _internal_set_yangle(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:AmurControls.CameraServos)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 xangle_;
  ::PROTOBUF_NAMESPACE_ID::int32 yangle_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_controls_2eproto;
};
// -------------------------------------------------------------------

class AmurControls_WheelMotors :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AmurControls.WheelMotors) */ {
 public:
  AmurControls_WheelMotors();
  virtual ~AmurControls_WheelMotors();

  AmurControls_WheelMotors(const AmurControls_WheelMotors& from);
  AmurControls_WheelMotors(AmurControls_WheelMotors&& from) noexcept
    : AmurControls_WheelMotors() {
    *this = ::std::move(from);
  }

  inline AmurControls_WheelMotors& operator=(const AmurControls_WheelMotors& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurControls_WheelMotors& operator=(AmurControls_WheelMotors&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurControls_WheelMotors& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurControls_WheelMotors* internal_default_instance() {
    return reinterpret_cast<const AmurControls_WheelMotors*>(
               &_AmurControls_WheelMotors_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(AmurControls_WheelMotors& a, AmurControls_WheelMotors& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurControls_WheelMotors* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurControls_WheelMotors* New() const final {
    return CreateMaybeMessage<AmurControls_WheelMotors>(nullptr);
  }

  AmurControls_WheelMotors* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurControls_WheelMotors>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurControls_WheelMotors& from);
  void MergeFrom(const AmurControls_WheelMotors& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurControls_WheelMotors* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AmurControls.WheelMotors";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_controls_2eproto);
    return ::descriptor_table_controls_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftPowerFieldNumber = 1,
    kLeftTimeFieldNumber = 2,
    kRightPowerFieldNumber = 3,
    kRightTimeFieldNumber = 4,
  };
  // int32 leftPower = 1;
  void clear_leftpower();
  ::PROTOBUF_NAMESPACE_ID::int32 leftpower() const;
  void set_leftpower(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_leftpower() const;
  void _internal_set_leftpower(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 leftTime = 2;
  void clear_lefttime();
  ::PROTOBUF_NAMESPACE_ID::int32 lefttime() const;
  void set_lefttime(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_lefttime() const;
  void _internal_set_lefttime(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 rightPower = 3;
  void clear_rightpower();
  ::PROTOBUF_NAMESPACE_ID::int32 rightpower() const;
  void set_rightpower(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rightpower() const;
  void _internal_set_rightpower(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 rightTime = 4;
  void clear_righttime();
  ::PROTOBUF_NAMESPACE_ID::int32 righttime() const;
  void set_righttime(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_righttime() const;
  void _internal_set_righttime(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:AmurControls.WheelMotors)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 leftpower_;
  ::PROTOBUF_NAMESPACE_ID::int32 lefttime_;
  ::PROTOBUF_NAMESPACE_ID::int32 rightpower_;
  ::PROTOBUF_NAMESPACE_ID::int32 righttime_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_controls_2eproto;
};
// -------------------------------------------------------------------

class AmurControls_HandMotors :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AmurControls.HandMotors) */ {
 public:
  AmurControls_HandMotors();
  virtual ~AmurControls_HandMotors();

  AmurControls_HandMotors(const AmurControls_HandMotors& from);
  AmurControls_HandMotors(AmurControls_HandMotors&& from) noexcept
    : AmurControls_HandMotors() {
    *this = ::std::move(from);
  }

  inline AmurControls_HandMotors& operator=(const AmurControls_HandMotors& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurControls_HandMotors& operator=(AmurControls_HandMotors&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurControls_HandMotors& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurControls_HandMotors* internal_default_instance() {
    return reinterpret_cast<const AmurControls_HandMotors*>(
               &_AmurControls_HandMotors_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(AmurControls_HandMotors& a, AmurControls_HandMotors& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurControls_HandMotors* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurControls_HandMotors* New() const final {
    return CreateMaybeMessage<AmurControls_HandMotors>(nullptr);
  }

  AmurControls_HandMotors* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurControls_HandMotors>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurControls_HandMotors& from);
  void MergeFrom(const AmurControls_HandMotors& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurControls_HandMotors* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AmurControls.HandMotors";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_controls_2eproto);
    return ::descriptor_table_controls_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLeftPowerFieldNumber = 1,
    kLeftTimeFieldNumber = 2,
    kRightPowerFieldNumber = 3,
    kRightTimeFieldNumber = 4,
    kLeftRelayFieldNumber = 5,
    kRightRelayFieldNumber = 6,
  };
  // int32 leftPower = 1;
  void clear_leftpower();
  ::PROTOBUF_NAMESPACE_ID::int32 leftpower() const;
  void set_leftpower(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_leftpower() const;
  void _internal_set_leftpower(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 leftTime = 2;
  void clear_lefttime();
  ::PROTOBUF_NAMESPACE_ID::int32 lefttime() const;
  void set_lefttime(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_lefttime() const;
  void _internal_set_lefttime(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 rightPower = 3;
  void clear_rightpower();
  ::PROTOBUF_NAMESPACE_ID::int32 rightpower() const;
  void set_rightpower(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_rightpower() const;
  void _internal_set_rightpower(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 rightTime = 4;
  void clear_righttime();
  ::PROTOBUF_NAMESPACE_ID::int32 righttime() const;
  void set_righttime(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_righttime() const;
  void _internal_set_righttime(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // bool leftRelay = 5;
  void clear_leftrelay();
  bool leftrelay() const;
  void set_leftrelay(bool value);
  private:
  bool _internal_leftrelay() const;
  void _internal_set_leftrelay(bool value);
  public:

  // bool rightRelay = 6;
  void clear_rightrelay();
  bool rightrelay() const;
  void set_rightrelay(bool value);
  private:
  bool _internal_rightrelay() const;
  void _internal_set_rightrelay(bool value);
  public:

  // @@protoc_insertion_point(class_scope:AmurControls.HandMotors)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 leftpower_;
  ::PROTOBUF_NAMESPACE_ID::int32 lefttime_;
  ::PROTOBUF_NAMESPACE_ID::int32 rightpower_;
  ::PROTOBUF_NAMESPACE_ID::int32 righttime_;
  bool leftrelay_;
  bool rightrelay_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_controls_2eproto;
};
// -------------------------------------------------------------------

class AmurControls_Light :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AmurControls.Light) */ {
 public:
  AmurControls_Light();
  virtual ~AmurControls_Light();

  AmurControls_Light(const AmurControls_Light& from);
  AmurControls_Light(AmurControls_Light&& from) noexcept
    : AmurControls_Light() {
    *this = ::std::move(from);
  }

  inline AmurControls_Light& operator=(const AmurControls_Light& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurControls_Light& operator=(AmurControls_Light&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurControls_Light& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurControls_Light* internal_default_instance() {
    return reinterpret_cast<const AmurControls_Light*>(
               &_AmurControls_Light_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(AmurControls_Light& a, AmurControls_Light& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurControls_Light* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurControls_Light* New() const final {
    return CreateMaybeMessage<AmurControls_Light>(nullptr);
  }

  AmurControls_Light* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurControls_Light>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurControls_Light& from);
  void MergeFrom(const AmurControls_Light& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurControls_Light* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AmurControls.Light";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_controls_2eproto);
    return ::descriptor_table_controls_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLedLeftPowerFieldNumber = 1,
    kLedRightPowerFieldNumber = 2,
  };
  // int32 ledLeftPower = 1;
  void clear_ledleftpower();
  ::PROTOBUF_NAMESPACE_ID::int32 ledleftpower() const;
  void set_ledleftpower(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_ledleftpower() const;
  void _internal_set_ledleftpower(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // int32 ledRightPower = 2;
  void clear_ledrightpower();
  ::PROTOBUF_NAMESPACE_ID::int32 ledrightpower() const;
  void set_ledrightpower(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_ledrightpower() const;
  void _internal_set_ledrightpower(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:AmurControls.Light)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::int32 ledleftpower_;
  ::PROTOBUF_NAMESPACE_ID::int32 ledrightpower_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_controls_2eproto;
};
// -------------------------------------------------------------------

class AmurControls_System :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AmurControls.System) */ {
 public:
  AmurControls_System();
  virtual ~AmurControls_System();

  AmurControls_System(const AmurControls_System& from);
  AmurControls_System(AmurControls_System&& from) noexcept
    : AmurControls_System() {
    *this = ::std::move(from);
  }

  inline AmurControls_System& operator=(const AmurControls_System& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurControls_System& operator=(AmurControls_System&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurControls_System& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurControls_System* internal_default_instance() {
    return reinterpret_cast<const AmurControls_System*>(
               &_AmurControls_System_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(AmurControls_System& a, AmurControls_System& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurControls_System* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurControls_System* New() const final {
    return CreateMaybeMessage<AmurControls_System>(nullptr);
  }

  AmurControls_System* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurControls_System>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurControls_System& from);
  void MergeFrom(const AmurControls_System& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurControls_System* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AmurControls.System";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_controls_2eproto);
    return ::descriptor_table_controls_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTimeOnAmurFieldNumber = 3,
    kHaltFlagFieldNumber = 1,
    kRestartFlagFieldNumber = 2,
  };
  // string timeOnAmur = 3;
  void clear_timeonamur();
  const std::string& timeonamur() const;
  void set_timeonamur(const std::string& value);
  void set_timeonamur(std::string&& value);
  void set_timeonamur(const char* value);
  void set_timeonamur(const char* value, size_t size);
  std::string* mutable_timeonamur();
  std::string* release_timeonamur();
  void set_allocated_timeonamur(std::string* timeonamur);
  private:
  const std::string& _internal_timeonamur() const;
  void _internal_set_timeonamur(const std::string& value);
  std::string* _internal_mutable_timeonamur();
  public:

  // bool haltFlag = 1;
  void clear_haltflag();
  bool haltflag() const;
  void set_haltflag(bool value);
  private:
  bool _internal_haltflag() const;
  void _internal_set_haltflag(bool value);
  public:

  // bool restartFlag = 2;
  void clear_restartflag();
  bool restartflag() const;
  void set_restartflag(bool value);
  private:
  bool _internal_restartflag() const;
  void _internal_set_restartflag(bool value);
  public:

  // @@protoc_insertion_point(class_scope:AmurControls.System)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr timeonamur_;
  bool haltflag_;
  bool restartflag_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_controls_2eproto;
};
// -------------------------------------------------------------------

class AmurControls :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:AmurControls) */ {
 public:
  AmurControls();
  virtual ~AmurControls();

  AmurControls(const AmurControls& from);
  AmurControls(AmurControls&& from) noexcept
    : AmurControls() {
    *this = ::std::move(from);
  }

  inline AmurControls& operator=(const AmurControls& from) {
    CopyFrom(from);
    return *this;
  }
  inline AmurControls& operator=(AmurControls&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const AmurControls& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AmurControls* internal_default_instance() {
    return reinterpret_cast<const AmurControls*>(
               &_AmurControls_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(AmurControls& a, AmurControls& b) {
    a.Swap(&b);
  }
  inline void Swap(AmurControls* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AmurControls* New() const final {
    return CreateMaybeMessage<AmurControls>(nullptr);
  }

  AmurControls* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AmurControls>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const AmurControls& from);
  void MergeFrom(const AmurControls& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AmurControls* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "AmurControls";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_controls_2eproto);
    return ::descriptor_table_controls_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef AmurControls_CameraServos CameraServos;
  typedef AmurControls_WheelMotors WheelMotors;
  typedef AmurControls_HandMotors HandMotors;
  typedef AmurControls_Light Light;
  typedef AmurControls_System System;

  // accessors -------------------------------------------------------

  enum : int {
    kCameraServosFieldNumber = 1,
    kWheelMotorsFieldNumber = 2,
    kHandMotorsFieldNumber = 3,
    kLightFieldNumber = 4,
    kSystemFieldNumber = 5,
  };
  // .AmurControls.CameraServos cameraServos = 1;
  bool has_cameraservos() const;
  private:
  bool _internal_has_cameraservos() const;
  public:
  void clear_cameraservos();
  const ::AmurControls_CameraServos& cameraservos() const;
  ::AmurControls_CameraServos* release_cameraservos();
  ::AmurControls_CameraServos* mutable_cameraservos();
  void set_allocated_cameraservos(::AmurControls_CameraServos* cameraservos);
  private:
  const ::AmurControls_CameraServos& _internal_cameraservos() const;
  ::AmurControls_CameraServos* _internal_mutable_cameraservos();
  public:

  // .AmurControls.WheelMotors wheelMotors = 2;
  bool has_wheelmotors() const;
  private:
  bool _internal_has_wheelmotors() const;
  public:
  void clear_wheelmotors();
  const ::AmurControls_WheelMotors& wheelmotors() const;
  ::AmurControls_WheelMotors* release_wheelmotors();
  ::AmurControls_WheelMotors* mutable_wheelmotors();
  void set_allocated_wheelmotors(::AmurControls_WheelMotors* wheelmotors);
  private:
  const ::AmurControls_WheelMotors& _internal_wheelmotors() const;
  ::AmurControls_WheelMotors* _internal_mutable_wheelmotors();
  public:

  // .AmurControls.HandMotors handMotors = 3;
  bool has_handmotors() const;
  private:
  bool _internal_has_handmotors() const;
  public:
  void clear_handmotors();
  const ::AmurControls_HandMotors& handmotors() const;
  ::AmurControls_HandMotors* release_handmotors();
  ::AmurControls_HandMotors* mutable_handmotors();
  void set_allocated_handmotors(::AmurControls_HandMotors* handmotors);
  private:
  const ::AmurControls_HandMotors& _internal_handmotors() const;
  ::AmurControls_HandMotors* _internal_mutable_handmotors();
  public:

  // .AmurControls.Light light = 4;
  bool has_light() const;
  private:
  bool _internal_has_light() const;
  public:
  void clear_light();
  const ::AmurControls_Light& light() const;
  ::AmurControls_Light* release_light();
  ::AmurControls_Light* mutable_light();
  void set_allocated_light(::AmurControls_Light* light);
  private:
  const ::AmurControls_Light& _internal_light() const;
  ::AmurControls_Light* _internal_mutable_light();
  public:

  // .AmurControls.System system = 5;
  bool has_system() const;
  private:
  bool _internal_has_system() const;
  public:
  void clear_system();
  const ::AmurControls_System& system() const;
  ::AmurControls_System* release_system();
  ::AmurControls_System* mutable_system();
  void set_allocated_system(::AmurControls_System* system);
  private:
  const ::AmurControls_System& _internal_system() const;
  ::AmurControls_System* _internal_mutable_system();
  public:

  // @@protoc_insertion_point(class_scope:AmurControls)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::AmurControls_CameraServos* cameraservos_;
  ::AmurControls_WheelMotors* wheelmotors_;
  ::AmurControls_HandMotors* handmotors_;
  ::AmurControls_Light* light_;
  ::AmurControls_System* system_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_controls_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AmurControls_CameraServos

// int32 xAngle = 1;
inline void AmurControls_CameraServos::clear_xangle() {
  xangle_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_CameraServos::_internal_xangle() const {
  return xangle_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_CameraServos::xangle() const {
  // @@protoc_insertion_point(field_get:AmurControls.CameraServos.xAngle)
  return _internal_xangle();
}
inline void AmurControls_CameraServos::_internal_set_xangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  xangle_ = value;
}
inline void AmurControls_CameraServos::set_xangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_xangle(value);
  // @@protoc_insertion_point(field_set:AmurControls.CameraServos.xAngle)
}

// int32 yAngle = 2;
inline void AmurControls_CameraServos::clear_yangle() {
  yangle_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_CameraServos::_internal_yangle() const {
  return yangle_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_CameraServos::yangle() const {
  // @@protoc_insertion_point(field_get:AmurControls.CameraServos.yAngle)
  return _internal_yangle();
}
inline void AmurControls_CameraServos::_internal_set_yangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  yangle_ = value;
}
inline void AmurControls_CameraServos::set_yangle(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_yangle(value);
  // @@protoc_insertion_point(field_set:AmurControls.CameraServos.yAngle)
}

// -------------------------------------------------------------------

// AmurControls_WheelMotors

// int32 leftPower = 1;
inline void AmurControls_WheelMotors::clear_leftpower() {
  leftpower_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_WheelMotors::_internal_leftpower() const {
  return leftpower_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_WheelMotors::leftpower() const {
  // @@protoc_insertion_point(field_get:AmurControls.WheelMotors.leftPower)
  return _internal_leftpower();
}
inline void AmurControls_WheelMotors::_internal_set_leftpower(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  leftpower_ = value;
}
inline void AmurControls_WheelMotors::set_leftpower(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_leftpower(value);
  // @@protoc_insertion_point(field_set:AmurControls.WheelMotors.leftPower)
}

// int32 leftTime = 2;
inline void AmurControls_WheelMotors::clear_lefttime() {
  lefttime_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_WheelMotors::_internal_lefttime() const {
  return lefttime_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_WheelMotors::lefttime() const {
  // @@protoc_insertion_point(field_get:AmurControls.WheelMotors.leftTime)
  return _internal_lefttime();
}
inline void AmurControls_WheelMotors::_internal_set_lefttime(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  lefttime_ = value;
}
inline void AmurControls_WheelMotors::set_lefttime(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_lefttime(value);
  // @@protoc_insertion_point(field_set:AmurControls.WheelMotors.leftTime)
}

// int32 rightPower = 3;
inline void AmurControls_WheelMotors::clear_rightpower() {
  rightpower_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_WheelMotors::_internal_rightpower() const {
  return rightpower_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_WheelMotors::rightpower() const {
  // @@protoc_insertion_point(field_get:AmurControls.WheelMotors.rightPower)
  return _internal_rightpower();
}
inline void AmurControls_WheelMotors::_internal_set_rightpower(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  rightpower_ = value;
}
inline void AmurControls_WheelMotors::set_rightpower(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rightpower(value);
  // @@protoc_insertion_point(field_set:AmurControls.WheelMotors.rightPower)
}

// int32 rightTime = 4;
inline void AmurControls_WheelMotors::clear_righttime() {
  righttime_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_WheelMotors::_internal_righttime() const {
  return righttime_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_WheelMotors::righttime() const {
  // @@protoc_insertion_point(field_get:AmurControls.WheelMotors.rightTime)
  return _internal_righttime();
}
inline void AmurControls_WheelMotors::_internal_set_righttime(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  righttime_ = value;
}
inline void AmurControls_WheelMotors::set_righttime(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_righttime(value);
  // @@protoc_insertion_point(field_set:AmurControls.WheelMotors.rightTime)
}

// -------------------------------------------------------------------

// AmurControls_HandMotors

// int32 leftPower = 1;
inline void AmurControls_HandMotors::clear_leftpower() {
  leftpower_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_HandMotors::_internal_leftpower() const {
  return leftpower_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_HandMotors::leftpower() const {
  // @@protoc_insertion_point(field_get:AmurControls.HandMotors.leftPower)
  return _internal_leftpower();
}
inline void AmurControls_HandMotors::_internal_set_leftpower(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  leftpower_ = value;
}
inline void AmurControls_HandMotors::set_leftpower(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_leftpower(value);
  // @@protoc_insertion_point(field_set:AmurControls.HandMotors.leftPower)
}

// int32 leftTime = 2;
inline void AmurControls_HandMotors::clear_lefttime() {
  lefttime_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_HandMotors::_internal_lefttime() const {
  return lefttime_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_HandMotors::lefttime() const {
  // @@protoc_insertion_point(field_get:AmurControls.HandMotors.leftTime)
  return _internal_lefttime();
}
inline void AmurControls_HandMotors::_internal_set_lefttime(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  lefttime_ = value;
}
inline void AmurControls_HandMotors::set_lefttime(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_lefttime(value);
  // @@protoc_insertion_point(field_set:AmurControls.HandMotors.leftTime)
}

// int32 rightPower = 3;
inline void AmurControls_HandMotors::clear_rightpower() {
  rightpower_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_HandMotors::_internal_rightpower() const {
  return rightpower_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_HandMotors::rightpower() const {
  // @@protoc_insertion_point(field_get:AmurControls.HandMotors.rightPower)
  return _internal_rightpower();
}
inline void AmurControls_HandMotors::_internal_set_rightpower(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  rightpower_ = value;
}
inline void AmurControls_HandMotors::set_rightpower(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_rightpower(value);
  // @@protoc_insertion_point(field_set:AmurControls.HandMotors.rightPower)
}

// int32 rightTime = 4;
inline void AmurControls_HandMotors::clear_righttime() {
  righttime_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_HandMotors::_internal_righttime() const {
  return righttime_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_HandMotors::righttime() const {
  // @@protoc_insertion_point(field_get:AmurControls.HandMotors.rightTime)
  return _internal_righttime();
}
inline void AmurControls_HandMotors::_internal_set_righttime(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  righttime_ = value;
}
inline void AmurControls_HandMotors::set_righttime(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_righttime(value);
  // @@protoc_insertion_point(field_set:AmurControls.HandMotors.rightTime)
}

// bool leftRelay = 5;
inline void AmurControls_HandMotors::clear_leftrelay() {
  leftrelay_ = false;
}
inline bool AmurControls_HandMotors::_internal_leftrelay() const {
  return leftrelay_;
}
inline bool AmurControls_HandMotors::leftrelay() const {
  // @@protoc_insertion_point(field_get:AmurControls.HandMotors.leftRelay)
  return _internal_leftrelay();
}
inline void AmurControls_HandMotors::_internal_set_leftrelay(bool value) {
  
  leftrelay_ = value;
}
inline void AmurControls_HandMotors::set_leftrelay(bool value) {
  _internal_set_leftrelay(value);
  // @@protoc_insertion_point(field_set:AmurControls.HandMotors.leftRelay)
}

// bool rightRelay = 6;
inline void AmurControls_HandMotors::clear_rightrelay() {
  rightrelay_ = false;
}
inline bool AmurControls_HandMotors::_internal_rightrelay() const {
  return rightrelay_;
}
inline bool AmurControls_HandMotors::rightrelay() const {
  // @@protoc_insertion_point(field_get:AmurControls.HandMotors.rightRelay)
  return _internal_rightrelay();
}
inline void AmurControls_HandMotors::_internal_set_rightrelay(bool value) {
  
  rightrelay_ = value;
}
inline void AmurControls_HandMotors::set_rightrelay(bool value) {
  _internal_set_rightrelay(value);
  // @@protoc_insertion_point(field_set:AmurControls.HandMotors.rightRelay)
}

// -------------------------------------------------------------------

// AmurControls_Light

// int32 ledLeftPower = 1;
inline void AmurControls_Light::clear_ledleftpower() {
  ledleftpower_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_Light::_internal_ledleftpower() const {
  return ledleftpower_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_Light::ledleftpower() const {
  // @@protoc_insertion_point(field_get:AmurControls.Light.ledLeftPower)
  return _internal_ledleftpower();
}
inline void AmurControls_Light::_internal_set_ledleftpower(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  ledleftpower_ = value;
}
inline void AmurControls_Light::set_ledleftpower(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_ledleftpower(value);
  // @@protoc_insertion_point(field_set:AmurControls.Light.ledLeftPower)
}

// int32 ledRightPower = 2;
inline void AmurControls_Light::clear_ledrightpower() {
  ledrightpower_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_Light::_internal_ledrightpower() const {
  return ledrightpower_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 AmurControls_Light::ledrightpower() const {
  // @@protoc_insertion_point(field_get:AmurControls.Light.ledRightPower)
  return _internal_ledrightpower();
}
inline void AmurControls_Light::_internal_set_ledrightpower(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  ledrightpower_ = value;
}
inline void AmurControls_Light::set_ledrightpower(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_ledrightpower(value);
  // @@protoc_insertion_point(field_set:AmurControls.Light.ledRightPower)
}

// -------------------------------------------------------------------

// AmurControls_System

// bool haltFlag = 1;
inline void AmurControls_System::clear_haltflag() {
  haltflag_ = false;
}
inline bool AmurControls_System::_internal_haltflag() const {
  return haltflag_;
}
inline bool AmurControls_System::haltflag() const {
  // @@protoc_insertion_point(field_get:AmurControls.System.haltFlag)
  return _internal_haltflag();
}
inline void AmurControls_System::_internal_set_haltflag(bool value) {
  
  haltflag_ = value;
}
inline void AmurControls_System::set_haltflag(bool value) {
  _internal_set_haltflag(value);
  // @@protoc_insertion_point(field_set:AmurControls.System.haltFlag)
}

// bool restartFlag = 2;
inline void AmurControls_System::clear_restartflag() {
  restartflag_ = false;
}
inline bool AmurControls_System::_internal_restartflag() const {
  return restartflag_;
}
inline bool AmurControls_System::restartflag() const {
  // @@protoc_insertion_point(field_get:AmurControls.System.restartFlag)
  return _internal_restartflag();
}
inline void AmurControls_System::_internal_set_restartflag(bool value) {
  
  restartflag_ = value;
}
inline void AmurControls_System::set_restartflag(bool value) {
  _internal_set_restartflag(value);
  // @@protoc_insertion_point(field_set:AmurControls.System.restartFlag)
}

// string timeOnAmur = 3;
inline void AmurControls_System::clear_timeonamur() {
  timeonamur_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline const std::string& AmurControls_System::timeonamur() const {
  // @@protoc_insertion_point(field_get:AmurControls.System.timeOnAmur)
  return _internal_timeonamur();
}
inline void AmurControls_System::set_timeonamur(const std::string& value) {
  _internal_set_timeonamur(value);
  // @@protoc_insertion_point(field_set:AmurControls.System.timeOnAmur)
}
inline std::string* AmurControls_System::mutable_timeonamur() {
  // @@protoc_insertion_point(field_mutable:AmurControls.System.timeOnAmur)
  return _internal_mutable_timeonamur();
}
inline const std::string& AmurControls_System::_internal_timeonamur() const {
  return timeonamur_.GetNoArena();
}
inline void AmurControls_System::_internal_set_timeonamur(const std::string& value) {
  
  timeonamur_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
}
inline void AmurControls_System::set_timeonamur(std::string&& value) {
  
  timeonamur_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:AmurControls.System.timeOnAmur)
}
inline void AmurControls_System::set_timeonamur(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  timeonamur_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:AmurControls.System.timeOnAmur)
}
inline void AmurControls_System::set_timeonamur(const char* value, size_t size) {
  
  timeonamur_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:AmurControls.System.timeOnAmur)
}
inline std::string* AmurControls_System::_internal_mutable_timeonamur() {
  
  return timeonamur_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* AmurControls_System::release_timeonamur() {
  // @@protoc_insertion_point(field_release:AmurControls.System.timeOnAmur)
  
  return timeonamur_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void AmurControls_System::set_allocated_timeonamur(std::string* timeonamur) {
  if (timeonamur != nullptr) {
    
  } else {
    
  }
  timeonamur_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), timeonamur);
  // @@protoc_insertion_point(field_set_allocated:AmurControls.System.timeOnAmur)
}

// -------------------------------------------------------------------

// AmurControls

// .AmurControls.CameraServos cameraServos = 1;
inline bool AmurControls::_internal_has_cameraservos() const {
  return this != internal_default_instance() && cameraservos_ != nullptr;
}
inline bool AmurControls::has_cameraservos() const {
  return _internal_has_cameraservos();
}
inline void AmurControls::clear_cameraservos() {
  if (GetArenaNoVirtual() == nullptr && cameraservos_ != nullptr) {
    delete cameraservos_;
  }
  cameraservos_ = nullptr;
}
inline const ::AmurControls_CameraServos& AmurControls::_internal_cameraservos() const {
  const ::AmurControls_CameraServos* p = cameraservos_;
  return p != nullptr ? *p : *reinterpret_cast<const ::AmurControls_CameraServos*>(
      &::_AmurControls_CameraServos_default_instance_);
}
inline const ::AmurControls_CameraServos& AmurControls::cameraservos() const {
  // @@protoc_insertion_point(field_get:AmurControls.cameraServos)
  return _internal_cameraservos();
}
inline ::AmurControls_CameraServos* AmurControls::release_cameraservos() {
  // @@protoc_insertion_point(field_release:AmurControls.cameraServos)
  
  ::AmurControls_CameraServos* temp = cameraservos_;
  cameraservos_ = nullptr;
  return temp;
}
inline ::AmurControls_CameraServos* AmurControls::_internal_mutable_cameraservos() {
  
  if (cameraservos_ == nullptr) {
    auto* p = CreateMaybeMessage<::AmurControls_CameraServos>(GetArenaNoVirtual());
    cameraservos_ = p;
  }
  return cameraservos_;
}
inline ::AmurControls_CameraServos* AmurControls::mutable_cameraservos() {
  // @@protoc_insertion_point(field_mutable:AmurControls.cameraServos)
  return _internal_mutable_cameraservos();
}
inline void AmurControls::set_allocated_cameraservos(::AmurControls_CameraServos* cameraservos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cameraservos_;
  }
  if (cameraservos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cameraservos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cameraservos, submessage_arena);
    }
    
  } else {
    
  }
  cameraservos_ = cameraservos;
  // @@protoc_insertion_point(field_set_allocated:AmurControls.cameraServos)
}

// .AmurControls.WheelMotors wheelMotors = 2;
inline bool AmurControls::_internal_has_wheelmotors() const {
  return this != internal_default_instance() && wheelmotors_ != nullptr;
}
inline bool AmurControls::has_wheelmotors() const {
  return _internal_has_wheelmotors();
}
inline void AmurControls::clear_wheelmotors() {
  if (GetArenaNoVirtual() == nullptr && wheelmotors_ != nullptr) {
    delete wheelmotors_;
  }
  wheelmotors_ = nullptr;
}
inline const ::AmurControls_WheelMotors& AmurControls::_internal_wheelmotors() const {
  const ::AmurControls_WheelMotors* p = wheelmotors_;
  return p != nullptr ? *p : *reinterpret_cast<const ::AmurControls_WheelMotors*>(
      &::_AmurControls_WheelMotors_default_instance_);
}
inline const ::AmurControls_WheelMotors& AmurControls::wheelmotors() const {
  // @@protoc_insertion_point(field_get:AmurControls.wheelMotors)
  return _internal_wheelmotors();
}
inline ::AmurControls_WheelMotors* AmurControls::release_wheelmotors() {
  // @@protoc_insertion_point(field_release:AmurControls.wheelMotors)
  
  ::AmurControls_WheelMotors* temp = wheelmotors_;
  wheelmotors_ = nullptr;
  return temp;
}
inline ::AmurControls_WheelMotors* AmurControls::_internal_mutable_wheelmotors() {
  
  if (wheelmotors_ == nullptr) {
    auto* p = CreateMaybeMessage<::AmurControls_WheelMotors>(GetArenaNoVirtual());
    wheelmotors_ = p;
  }
  return wheelmotors_;
}
inline ::AmurControls_WheelMotors* AmurControls::mutable_wheelmotors() {
  // @@protoc_insertion_point(field_mutable:AmurControls.wheelMotors)
  return _internal_mutable_wheelmotors();
}
inline void AmurControls::set_allocated_wheelmotors(::AmurControls_WheelMotors* wheelmotors) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete wheelmotors_;
  }
  if (wheelmotors) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      wheelmotors = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, wheelmotors, submessage_arena);
    }
    
  } else {
    
  }
  wheelmotors_ = wheelmotors;
  // @@protoc_insertion_point(field_set_allocated:AmurControls.wheelMotors)
}

// .AmurControls.HandMotors handMotors = 3;
inline bool AmurControls::_internal_has_handmotors() const {
  return this != internal_default_instance() && handmotors_ != nullptr;
}
inline bool AmurControls::has_handmotors() const {
  return _internal_has_handmotors();
}
inline void AmurControls::clear_handmotors() {
  if (GetArenaNoVirtual() == nullptr && handmotors_ != nullptr) {
    delete handmotors_;
  }
  handmotors_ = nullptr;
}
inline const ::AmurControls_HandMotors& AmurControls::_internal_handmotors() const {
  const ::AmurControls_HandMotors* p = handmotors_;
  return p != nullptr ? *p : *reinterpret_cast<const ::AmurControls_HandMotors*>(
      &::_AmurControls_HandMotors_default_instance_);
}
inline const ::AmurControls_HandMotors& AmurControls::handmotors() const {
  // @@protoc_insertion_point(field_get:AmurControls.handMotors)
  return _internal_handmotors();
}
inline ::AmurControls_HandMotors* AmurControls::release_handmotors() {
  // @@protoc_insertion_point(field_release:AmurControls.handMotors)
  
  ::AmurControls_HandMotors* temp = handmotors_;
  handmotors_ = nullptr;
  return temp;
}
inline ::AmurControls_HandMotors* AmurControls::_internal_mutable_handmotors() {
  
  if (handmotors_ == nullptr) {
    auto* p = CreateMaybeMessage<::AmurControls_HandMotors>(GetArenaNoVirtual());
    handmotors_ = p;
  }
  return handmotors_;
}
inline ::AmurControls_HandMotors* AmurControls::mutable_handmotors() {
  // @@protoc_insertion_point(field_mutable:AmurControls.handMotors)
  return _internal_mutable_handmotors();
}
inline void AmurControls::set_allocated_handmotors(::AmurControls_HandMotors* handmotors) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete handmotors_;
  }
  if (handmotors) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      handmotors = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, handmotors, submessage_arena);
    }
    
  } else {
    
  }
  handmotors_ = handmotors;
  // @@protoc_insertion_point(field_set_allocated:AmurControls.handMotors)
}

// .AmurControls.Light light = 4;
inline bool AmurControls::_internal_has_light() const {
  return this != internal_default_instance() && light_ != nullptr;
}
inline bool AmurControls::has_light() const {
  return _internal_has_light();
}
inline void AmurControls::clear_light() {
  if (GetArenaNoVirtual() == nullptr && light_ != nullptr) {
    delete light_;
  }
  light_ = nullptr;
}
inline const ::AmurControls_Light& AmurControls::_internal_light() const {
  const ::AmurControls_Light* p = light_;
  return p != nullptr ? *p : *reinterpret_cast<const ::AmurControls_Light*>(
      &::_AmurControls_Light_default_instance_);
}
inline const ::AmurControls_Light& AmurControls::light() const {
  // @@protoc_insertion_point(field_get:AmurControls.light)
  return _internal_light();
}
inline ::AmurControls_Light* AmurControls::release_light() {
  // @@protoc_insertion_point(field_release:AmurControls.light)
  
  ::AmurControls_Light* temp = light_;
  light_ = nullptr;
  return temp;
}
inline ::AmurControls_Light* AmurControls::_internal_mutable_light() {
  
  if (light_ == nullptr) {
    auto* p = CreateMaybeMessage<::AmurControls_Light>(GetArenaNoVirtual());
    light_ = p;
  }
  return light_;
}
inline ::AmurControls_Light* AmurControls::mutable_light() {
  // @@protoc_insertion_point(field_mutable:AmurControls.light)
  return _internal_mutable_light();
}
inline void AmurControls::set_allocated_light(::AmurControls_Light* light) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete light_;
  }
  if (light) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      light = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, light, submessage_arena);
    }
    
  } else {
    
  }
  light_ = light;
  // @@protoc_insertion_point(field_set_allocated:AmurControls.light)
}

// .AmurControls.System system = 5;
inline bool AmurControls::_internal_has_system() const {
  return this != internal_default_instance() && system_ != nullptr;
}
inline bool AmurControls::has_system() const {
  return _internal_has_system();
}
inline void AmurControls::clear_system() {
  if (GetArenaNoVirtual() == nullptr && system_ != nullptr) {
    delete system_;
  }
  system_ = nullptr;
}
inline const ::AmurControls_System& AmurControls::_internal_system() const {
  const ::AmurControls_System* p = system_;
  return p != nullptr ? *p : *reinterpret_cast<const ::AmurControls_System*>(
      &::_AmurControls_System_default_instance_);
}
inline const ::AmurControls_System& AmurControls::system() const {
  // @@protoc_insertion_point(field_get:AmurControls.system)
  return _internal_system();
}
inline ::AmurControls_System* AmurControls::release_system() {
  // @@protoc_insertion_point(field_release:AmurControls.system)
  
  ::AmurControls_System* temp = system_;
  system_ = nullptr;
  return temp;
}
inline ::AmurControls_System* AmurControls::_internal_mutable_system() {
  
  if (system_ == nullptr) {
    auto* p = CreateMaybeMessage<::AmurControls_System>(GetArenaNoVirtual());
    system_ = p;
  }
  return system_;
}
inline ::AmurControls_System* AmurControls::mutable_system() {
  // @@protoc_insertion_point(field_mutable:AmurControls.system)
  return _internal_mutable_system();
}
inline void AmurControls::set_allocated_system(::AmurControls_System* system) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete system_;
  }
  if (system) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      system = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, system, submessage_arena);
    }
    
  } else {
    
  }
  system_ = system;
  // @@protoc_insertion_point(field_set_allocated:AmurControls.system)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_controls_2eproto
